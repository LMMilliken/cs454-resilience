docstring,code,generated_comment
"str->list
  Convert XML to URL List.
  From Biligrab.","def foo(xml_data):
  rawurl = []
  dom = parseString(xml_data)
  for node in dom.getElementsByTagName('durl'):
  url = node.getElementsByTagName('url')[0]
  rawurl.append(url.childNodes[0].data)
  return rawurl",This function parses XML data to extract URLs from 'durl' elements and returns a list of these URLs.
Downloads Dailymotion videos by URL.,"def foo(url, output_dir='.', merge=True, info_only=False, **kwargs):
 
  html = get_content(rebuilt_url(url))
  info = json.loads(match1(html, r'qualities"":({.+?}),""'))
  title = match1(html, r'""video_title""\s*:\s*""([^""]+)""') or \
  match1(html, r'""title""\s*:\s*""([^""]+)""')
  title = unicodize(title)
 
  for quality in ['1080','720','480','380','240','144','auto']:
  try:
  real_url = info[quality][1][""url""]
  if real_url:
  break
  except KeyError:
  pass
 
  mime, ext, size = url_info(real_url)
 
  print_info(site_info, title, mime, size)
  if not info_only:
  download_urls([real_url], title, ext, size, output_dir=output_dir, merge=merge)","This function extracts video information from a URL, selects a quality, downloads video data, and saves it to a specified directory."
Format text with color or other effects into ANSI escaped string.,"def foo(text, *colors):
  
  return ""\33[{}m{content}\33[{}m"".format("";"".join([str(color) for color in colors]), RESET, content=text) if IS_ANSI_TERMINAL and colors else text",This function formats the input text with ANSI color codes if the terminal supports ANSI colors and if any colors are provided.
Print a log message to standard error.,"def foo(text, *colors):
  
  sys.stderr.write(sprint(""{}: {}"".format(script_name, text), *colors) + ""\n"")",This function prints a formatted error message with optional colors to the standard error stream.
Detect operating system.,"def foo():
  
 
  
  
 
  syst = system().lower()
  os = 'unknown'
 
  if 'cygwin' in syst:
  os = 'cygwin'
  elif 'darwin' in syst:
  os = 'mac'
  elif 'linux' in syst:
  os = 'linux'
  
  try:
  with open('/proc/version', 'r') as f:
  if 'microsoft' in f.read().lower():
  os = 'wsl'
  except: pass
  elif 'windows' in syst:
  os = 'windows'
  elif 'bsd' in syst:
  os = 'bsd'
 
  return os",This function detects and returns the operating system type based on environmental variables and the presence of certain files.
Splicing URLs according to video ID to get video details,"def foo(video_id):
  
  
  data = [""""] * 256
  for index, _ in enumerate(data):
  t = index
  for i in range(8):
  t = -306674912 ^ unsigned_right_shitf(t, 1) if 1 & t else unsigned_right_shitf(t, 1)
  data[index] = t
 
  def tmp():
  rand_num = random.random()
  path = ""/video/urls/v/1/toutiao/mp4/{video_id}?r={random_num}"".format(video_id=video_id,
  random_num=str(rand_num)[2:])
  e = o = r = -1
  i, a = 0, len(path)
  while i < a:
  e = ord(path[i])
  i += 1
  if e < 128:
  r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ e)]
  else:
  if e < 2048:
  r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (192 | e >> 6 & 31))]
  r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (128 | 63 & e))]
  else:
  if 55296 <= e < 57344:
  e = (1023 & e) + 64
  i += 1
  o = 1023 & t.url(i)
  r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (240 | e >> 8 & 7))]
  r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (128 | e >> 2 & 63))]
  r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (128 | o >> 6 & 15 | (3 & e) << 4))]
  r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (128 | 63 & o))]
  else:
  r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (224 | e >> 12 & 15))]
  r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (128 | e >> 6 & 63))]
  r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (128 | 63 & e))]
 
  return ""https://ib.365yg.com{path}&s={param}"".format(path=path, param=unsigned_right_shitf(r ^ -1, 0))
 
  while 1:
  url = tmp()
  if url.split(""="")[-1][0] != ""-"": 
  return url",This function generates a signed URL for a video by encoding its path using a custom checksum algorithm and appending the result as a query parameter.
Converts a string to a valid filename.,"def foo(text, os=detect_os()):
  
 
  
  text = text.translate({
  0: None,
  ord('/'): '-',
  ord('|'): '-',
  })
 
  
  if os == 'windows' or os == 'cygwin' or os == 'wsl':
  
  text = text.translate({
  
  ord(':'): '-',
  ord('*'): '-',
  ord('?'): '-',
  ord('\\'): '-',
  ord('\""'): '\'',
  
  ord('+'): '-',
  ord('<'): '-',
  ord('>'): '-',
  ord('['): '(',
  ord(']'): ')',
  ord('\t'): ' ',
  })
  else:
  
  if os == 'mac':
  
  text = text.translate({
  ord(':'): '-',
  })
 
  
  if text.startswith("".""):
  text = text[1:]
 
  text = text[:80] 
  return text",This function sanitizes a given string to ensure it's a valid filename across different operating systems by replacing or removing potentially problematic characters.
Downloads CBS videos by URL.,"def foo(url, output_dir='.', merge=True, info_only=False, **kwargs):
  
 
  html = get_content(url)
  pid = match1(html, r'video\.settings\.pid\s*=\s*\'([^\']+)\'')
  title = match1(html, r'video\.settings\.title\s*=\s*\""([^\""]+)\""')
 
  theplatform_download_by_pid(pid, title, output_dir=output_dir, merge=merge, info_only=info_only)","This function retrieves video content from a webpage, identifies its ID and title, and downloads it to a specified directory with optional merging."
"Override the original one
  Ugly ugly dirty hack","def foo(self, **kwargs):
  
  if 'json_output' in kwargs and kwargs['json_output']:
  json_output.output(self)
  elif 'info_only' in kwargs and kwargs['info_only']:
  if 'stream_id' in kwargs and kwargs['stream_id']:
  
  stream_id = kwargs['stream_id']
  if 'index' not in kwargs:
  self.p(stream_id)
  else:
  self.p_i(stream_id)
  else:
  
  if 'index' not in kwargs:
  self.p([])
  else:
  stream_id = self.streams_sorted[0]['id'] if 'id' in self.streams_sorted[0] else self.streams_sorted[0]['itag']
  self.p_i(stream_id)
 
  else:
  if 'stream_id' in kwargs and kwargs['stream_id']:
  
  stream_id = kwargs['stream_id']
  else:
  
  stream_id = self.streams_sorted[0]['id'] if 'id' in self.streams_sorted[0] else self.streams_sorted[0]['itag']
 
  if 'index' not in kwargs:
  self.p(stream_id)
  else:
  self.p_i(stream_id)
 
  if stream_id in self.streams:
  urls = self.streams[stream_id]['src']
  ext = self.streams[stream_id]['container']
  total_size = self.streams[stream_id]['size']
  else:
  urls = self.dash_streams[stream_id]['src']
  ext = self.dash_streams[stream_id]['container']
  total_size = self.dash_streams[stream_id]['size']
 
  if not urls:
  log.wtf('[Failed] Cannot extract video source.')
  
  
  
  download_url_ffmpeg(urls[0], self.title, 'mp4', output_dir=kwargs['output_dir'], merge=kwargs['merge'], stream=False)
 
  if not kwargs['caption']:
  print('Skipping captions.')
  return
  for lang in self.caption_tracks:
  filename = '%s.%s.srt' % (get_filename(self.title), lang)
  print('Saving %s ... ' % filename, end="""", flush=True)
  srt = self.caption_tracks[lang]
  with open(os.path.join(kwargs['output_dir'], filename),
  'w', encoding='utf-8') as x:
  x.write(srt)
  print('Done.')","This function processes video data, potentially exporting JSON, displaying info on specific streams, downloading video files, and saving caption tracks if provided."
"Scans through a string for substrings matched some patterns.
 
  Args:
  text: A string to be scanned.
  patterns: a list of regex pattern.
 
  Returns:
  a list if matched. empty if not.","def foo(text, patterns):
  
 
  ret = []
  for pattern in patterns:
  match = re.findall(pattern, text)
  ret += match
 
  return ret",This function searches for all occurrences of multiple patterns in a given string and aggregates the matches into a single list.
"Parses the query string of a URL and returns the value of a parameter.
 
  Args:
  url: A URL.
  param: A string representing the name of the parameter.
 
  Returns:
  The value of the parameter.","def foo(url, param):
  
 
  try:
  return parse.parse_qs(parse.urlparse(url).query)[param][0]
  except:
  return None","This function extracts the value of a specified query parameter from a given URL, returning `None` if the parameter isn't found."
"Gets the content of a URL via sending a HTTP GET request.
 
  Args:
  url: A URL.
  headers: Request headers used by the client.
  decoded: Whether decode the response body using UTF-8 or the charset specified in Content-Type.
 
  Returns:
  The content as a string.","def foo(url, headers={}, decoded=True):
  
 
  logging.debug('foo: %s' % url)
 
  req = request.Request(url, headers=headers)
  if cookies:
  cookies.add_cookie_header(req)
  req.headers.update(req.unredirected_hdrs)
 
  response = urlopen_with_retry(req)
  data = response.read()
 
  
  content_encoding = response.getheader('Content-Encoding')
  if content_encoding == 'gzip':
  data = ungzip(data)
  elif content_encoding == 'deflate':
  data = undeflate(data)
 
  
  if decoded:
  charset = match1(
  response.getheader('Content-Type', ''), r'charset=([\w-]+)'
  )
  if charset is not None:
  data = data.decode(charset, 'ignore')
  else:
  data = data.decode('utf-8', 'ignore')
 
  return data","This function retrieves content from a specified URL, optionally using cookies and headers, and decodes the data based on the content encoding and character set."
"Post the content of a URL via sending a HTTP POST request.
 
  Args:
  url: A URL.
  headers: Request headers used by the client.
  decoded: Whether decode the response body using UTF-8 or the charset specified in Content-Type.
 
  Returns:
  The content as a string.","def foo(url, headers={}, post_data={}, decoded=True, **kwargs):
  
  if kwargs.get('post_data_raw'):
  logging.debug('foo: %s\npost_data_raw: %s' % (url, kwargs['post_data_raw']))
  else:
  logging.debug('foo: %s\npost_data: %s' % (url, post_data))
 
  req = request.Request(url, headers=headers)
  if cookies:
  cookies.add_cookie_header(req)
  req.headers.update(req.unredirected_hdrs)
  if kwargs.get('post_data_raw'):
  post_data_enc = bytes(kwargs['post_data_raw'], 'utf-8')
  else:
  post_data_enc = bytes(parse.urlencode(post_data), 'utf-8')
  response = urlopen_with_retry(req, data=post_data_enc)
  data = response.read()
 
  
  content_encoding = response.getheader('Content-Encoding')
  if content_encoding == 'gzip':
  data = ungzip(data)
  elif content_encoding == 'deflate':
  data = undeflate(data)
 
  
  if decoded:
  charset = match1(
  response.getheader('Content-Type'), r'charset=([\w-]+)'
  )
  if charset is not None:
  data = data.decode(charset)
  else:
  data = data.decode('utf-8')
 
  return data","This function performs an HTTP request to a given URL with optional custom headers, POST data, handles cookie management, retries on fail, and decodes the response content."
Parses host name and port number from a string.,"def foo(host):
  
  if re.match(r'^(\d+)$', host) is not None:
  return (""0.0.0.0"", int(host))
  if re.match(r'^(\w+)://', host) is None:
  host = ""//"" + host
  o = parse.urlparse(host)
  hostname = o.hostname or ""0.0.0.0""
  port = o.port or 0
  return (hostname, port)",This function parses a host string to extract and return a tuple with the hostname and port number.
"Checks if a task is either queued or running in this executor
 
  :param task_instance: TaskInstance
  :return: True if the task is known to this executor","def foo(self, task_instance):
  
  if task_instance.key in self.queued_tasks or task_instance.key in self.running:
  return True","This function checks if a task is already in the queue or running, and returns True if it is."
"Returns and flush the event buffer. In case dag_ids is specified
  it will only return and flush events for the given dag_ids. Otherwise
  it returns and flushes all
 
  :param dag_ids: to dag_ids to return events for, if None returns all
  :return: a dict of events","def foo(self, dag_ids=None):
  
  cleared_events = dict()
  if dag_ids is None:
  cleared_events = self.event_buffer
  self.event_buffer = dict()
  else:
  for key in list(self.event_buffer.keys()):
  dag_id, _, _, _ = key
  if dag_id in dag_ids:
  cleared_events[key] = self.event_buffer.pop(key)
 
  return cleared_events","This function clears specific events from an event buffer, returning the cleared events as a dictionary, and resets the buffer either partially or entirely."
Returns a snowflake.connection object,"def foo(self):
  
  conn_config = self._get_conn_params()
  conn = snowflake.connector.connect(**conn_config)
  return conn",This function establishes a connection to a Snowflake database using provided connection parameters.
"returns aws_access_key_id, aws_secret_access_key
  from extra
 
  intended to be used by external import and export statements","def foo(self):
  
  if self.snowflake_conn_id:
  connection_object = self.get_connection(self.snowflake_conn_id)
  if 'aws_secret_access_key' in connection_object.extra_dejson:
  aws_access_key_id = connection_object.extra_dejson.get(
  'aws_access_key_id')
  aws_secret_access_key = connection_object.extra_dejson.get(
  'aws_secret_access_key')
  return aws_access_key_id, aws_secret_access_key","This function checks for a Snowflake connection ID, retrieves connection details, and returns AWS credentials if available."
"Fetches a field from extras, and returns it. This is some Airflow
  magic. The grpc hook type adds custom UI elements
  to the hook page, which allow admins to specify scopes, credential pem files, etc.
  They get formatted as shown below.","def foo(self, field_name, default=None):
  
  full_field_name = 'extra__grpc__{}'.format(field_name)
  if full_field_name in self.extras:
  return self.extras[full_field_name]
  else:
  return default","This function retrieves a named field from a dictionary, with optional namespacing and a default return value if the field is not found."
"Executes SQL using psycopg2 copy_expert method.
  Necessary to execute COPY command without access to a superuser.
 
  Note: if this method is called with a ""COPY FROM"" statement and
  the specified input file does not exist, it creates an empty
  file and no data is loaded, but the operation succeeds.
  So if users want to be aware when the input file does not exist,
  they have to check its existence by themselves.","def foo(self, sql, filename, open=open):
  
  if not os.path.isfile(filename):
  with open(filename, 'w'):
  pass
 
  with open(filename, 'r+') as f:
  with closing(self.get_conn()) as conn:
  with closing(conn.cursor()) as cur:
  cur.copy_expert(sql, f)
  f.truncate(f.tell())
  conn.commit()","This function checks if a file exists, creates it if not, runs a SQL copy command, and writes the results to the file, ensuring transactional integrity."
Dumps a database table into a tab-delimited file,"def foo(self, table, tmp_file):
  
  self.copy_expert(""COPY {table} TO STDOUT"".format(table=table), tmp_file)",This function uses a PostgreSQL COPY command to export data from a specified table into a file.
Uploads the file to Google cloud storage,"def foo(self, context):
  
  hook = GoogleCloudStorageHook(
  google_cloud_storage_conn_id=self.google_cloud_storage_conn_id,
  delegate_to=self.delegate_to)
 
  hook.upload(
  bucket_name=self.bucket,
  object_name=self.dst,
  mime_type=self.mime_type,
  filename=self.src,
  gzip=self.gzip,
  )",This function initializes a Google Cloud Storage hook and uploads a file to a specified bucket with given parameters such as MIME type and compression.
"Gets the max partition for a table.
 
  :param schema: The hive schema the table lives in
  :type schema: str
  :param table: The hive table you are interested in, supports the dot
  notation as in ""my_database.my_table"", if a dot is found,
  the schema param is disregarded
  :type table: str
  :param metastore_conn_id: The hive connection you are interested in.
  If your default is set you don't need to use this parameter.
  :type metastore_conn_id: str
  :param filter_map: partition_key:partition_value map used for partition filtering,
  e.g. {'key1': 'value1', 'key2': 'value2'}.
  Only partitions matching all partition_key:partition_value
  pairs will be considered as candidates of max partition.
  :type filter_map: map
  :param field: the field to get the max value from. If there's only
  one partition field, this will be inferred
  :type field: str
 
  >>> max_partition('airflow.static_babynames_partitioned')
  '2015-01-01'","def foo(
  table, schema=""default"", field=None, filter_map=None,
  metastore_conn_id='metastore_default'):
  
  from airflow.hooks.hive_hooks import HiveMetastoreHook
  if '.' in table:
  schema, table = table.split('.')
  hh = HiveMetastoreHook(metastore_conn_id=metastore_conn_id)
  return hh.foo(
  schema=schema, table_name=table, field=field, filter_map=filter_map)","This function interacts with a Hive metastore to retrieve metadata about a given table, optionally filtered by specific criteria."
Returns a mysql connection object,"def foo(self):
  
  conn = self.get_connection(self.mysql_conn_id)
  conn_config = {
  ""user"": conn.login,
  ""passwd"": conn.password or '',
  ""host"": conn.host or 'localhost',
  ""db"": self.schema or conn.schema or ''
  }
 
  if not conn.port:
  conn_config[""port""] = 3306
  else:
  conn_config[""port""] = int(conn.port)
 
  if conn.extra_dejson.get('charset', False):
  conn_config[""charset""] = conn.extra_dejson[""charset""]
  if (conn_config[""charset""]).lower() == 'utf8' or\
  (conn_config[""charset""]).lower() == 'utf-8':
  conn_config[""use_unicode""] = True
  if conn.extra_dejson.get('cursor', False):
  if (conn.extra_dejson[""cursor""]).lower() == 'sscursor':
  conn_config[""cursorclass""] = MySQLdb.cursors.SSCursor
  elif (conn.extra_dejson[""cursor""]).lower() == 'dictcursor':
  conn_config[""cursorclass""] = MySQLdb.cursors.DictCursor
  elif (conn.extra_dejson[""cursor""]).lower() == 'ssdictcursor':
  conn_config[""cursorclass""] = MySQLdb.cursors.SSDictCursor
  local_infile = conn.extra_dejson.get('local_infile', False)
  if conn.extra_dejson.get('ssl', False):
  
  
  
  dejson_ssl = conn.extra_dejson['ssl']
  if isinstance(dejson_ssl, six.string_types):
  dejson_ssl = json.loads(dejson_ssl)
  conn_config['ssl'] = dejson_ssl
  if conn.extra_dejson.get('unix_socket'):
  conn_config['unix_socket'] = conn.extra_dejson['unix_socket']
  if local_infile:
  conn_config[""local_infile""] = 1
  conn = MySQLdb.connect(**conn_config)
  return conn","This function establishes a MySQL database connection using configuration parameters, supports SSL connections, and sets cursor behavior based on specified options."
"Returns the state of a TaskInstance at the command line.
  >>> airflow task_state tutorial sleep 2015-01-01
  success","def foo(args):
  
  dag = get_dag(args)
  task = dag.get_task(task_id=args.task_id)
  ti = TaskInstance(task, args.execution_date)
  print(ti.current_state())",This function retrieves the current state of a specific task instance within an Apache Airflow DAG on a given execution date and prints it.
"Retrieves connection to Cloud Translate
 
  :return: Google Cloud Translate client object.
  :rtype: Client","def foo(self):
  
  if not self._client:
  self._client = Client(credentials=self._get_credentials())
  return self._client",This function lazily initializes and returns a client object using provided credentials if it hasn't been created yet.
"Translate a string or list of strings.
 
  See https://cloud.google.com/translate/docs/translating-text
 
  :type values: str or list
  :param values: String or list of strings to translate.
 
  :type target_language: str
  :param target_language: The language to translate results into. This
  is required by the API and defaults to
  the target language of the current instance.
 
  :type format_: str
  :param format_: (Optional) One of ``text`` or ``html``, to specify
  if the input text is plain text or HTML.
 
  :type source_language: str or None
  :param source_language: (Optional) The language of the text to
  be translated.
 
  :type model: str or None
  :param model: (Optional) The model used to translate the text, such
  as ``'base'`` or ``'nmt'``.
 
  :rtype: str or list
  :returns: A list of dictionaries for each queried value. Each
  dictionary typically contains three keys (though not
  all will be present in all cases)
 
  * ``detectedSourceLanguage``: The detected language (as an
  ISO 639-1 language code) of the text.
  * ``translatedText``: The translation of the text into the
  target language.
  * ``input``: The corresponding input value.
  * ``model``: The model used to translate the text.
 
  If only a single value is passed, then only a single
  dictionary will be returned.
  :raises: :class:`~exceptions.ValueError` if the number of
  values and translations differ.","def foo(
  self, values, target_language, format_=None, source_language=None, model=None
  ):
  
  client = self.get_conn()
 
  return client.translate(
  values=values,
  target_language=target_language,
  format_=format_,
  source_language=source_language,
  model=model,
  )",This function interfaces with a translation service client to return translations of provided values in the specified target language.
"Retrieves a resource containing information about a Cloud SQL instance.
 
  :param instance: Database instance ID. This does not include the project ID.
  :type instance: str
  :param project_id: Project ID of the project that contains the instance. If set
  to None or missing, the default project_id from the GCP connection is used.
  :type project_id: str
  :return: A Cloud SQL instance resource.
  :rtype: dict","def foo(self, instance, project_id=None):
  
  return self.get_conn().instances().get(
  project=project_id,
  instance=instance
  ).execute(num_retries=self.num_retries)",This function retrieves metadata for a specified database instance within a Google Cloud project using the project's API connection.
"Creates a new Cloud SQL instance.
 
  :param body: Body required by the Cloud SQL insert API, as described in
  https://cloud.google.com/sql/docs/mysql/admin-api/v1beta4/instances/insert#request-body.
  :type body: dict
  :param project_id: Project ID of the project that contains the instance. If set
  to None or missing, the default project_id from the GCP connection is used.
  :type project_id: str
  :return: None","def foo(self, body, project_id=None):
  
  response = self.get_conn().instances().insert(
  project=project_id,
  body=body
  ).execute(num_retries=self.num_retries)
  operation_name = response[""name""]
  self._wait_for_operation_to_complete(project_id=project_id,
  operation_name=operation_name)","This function creates a new instance on a cloud platform, waits for the operation to complete, and handles retries if necessary."
"Updates settings of a Cloud SQL instance.
 
  Caution: This is not a partial update, so you must include values for
  all the settings that you want to retain.
 
  :param body: Body required by the Cloud SQL patch API, as described in
  https://cloud.google.com/sql/docs/mysql/admin-api/v1beta4/instances/patch#request-body.
  :type body: dict
  :param instance: Cloud SQL instance ID. This does not include the project ID.
  :type instance: str
  :param project_id: Project ID of the project that contains the instance. If set
  to None or missing, the default project_id from the GCP connection is used.
  :type project_id: str
  :return: None","def foo(self, body, instance, project_id=None):
  
  response = self.get_conn().instances().patch(
  project=project_id,
  instance=instance,
  body=body
  ).execute(num_retries=self.num_retries)
  operation_name = response[""name""]
  self._wait_for_operation_to_complete(project_id=project_id,
  operation_name=operation_name)",This function updates an instance using a PATCH request and waits for the operation to complete before returning.
"Deletes a Cloud SQL instance.
 
  :param project_id: Project ID of the project that contains the instance. If set
  to None or missing, the default project_id from the GCP connection is used.
  :type project_id: str
  :param instance: Cloud SQL instance ID. This does not include the project ID.
  :type instance: str
  :return: None","def foo(self, instance, project_id=None):
  
  response = self.get_conn().instances().delete(
  project=project_id,
  instance=instance,
  ).execute(num_retries=self.num_retries)
  operation_name = response[""name""]
  self._wait_for_operation_to_complete(project_id=project_id,
  operation_name=operation_name)",This function deletes a cloud instance and waits for the deletion operation to complete before proceeding.
"Retrieves a database resource from a Cloud SQL instance.
 
  :param instance: Database instance ID. This does not include the project ID.
  :type instance: str
  :param database: Name of the database in the instance.
  :type database: str
  :param project_id: Project ID of the project that contains the instance. If set
  to None or missing, the default project_id from the GCP connection is used.
  :type project_id: str
  :return: A Cloud SQL database resource, as described in
  https://cloud.google.com/sql/docs/mysql/admin-api/v1beta4/databases#resource.
  :rtype: dict","def foo(self, instance, database, project_id=None):
  
  return self.get_conn().databases().get(
  project=project_id,
  instance=instance,
  database=database
  ).execute(num_retries=self.num_retries)",This function retrieves a specific database configuration from a cloud service by calling an API and returns the response.
"Creates a new database inside a Cloud SQL instance.
 
  :param instance: Database instance ID. This does not include the project ID.
  :type instance: str
  :param body: The request body, as described in
  https://cloud.google.com/sql/docs/mysql/admin-api/v1beta4/databases/insert#request-body.
  :type body: dict
  :param project_id: Project ID of the project that contains the instance. If set
  to None or missing, the default project_id from the GCP connection is used.
  :type project_id: str
  :return: None","def foo(self, instance, body, project_id=None):
  
  response = self.get_conn().databases().insert(
  project=project_id,
  instance=instance,
  body=body
  ).execute(num_retries=self.num_retries)
  operation_name = response[""name""]
  self._wait_for_operation_to_complete(project_id=project_id,
  operation_name=operation_name)",This function inserts a new database into a Cloud SQL instance and waits until the insert operation completes.
"Updates a database resource inside a Cloud SQL instance.
 
  This method supports patch semantics.
  See https://cloud.google.com/sql/docs/mysql/admin-api/how-tos/performance#patch.
 
  :param instance: Database instance ID. This does not include the project ID.
  :type instance: str
  :param database: Name of the database to be updated in the instance.
  :type database: str
  :param body: The request body, as described in
  https://cloud.google.com/sql/docs/mysql/admin-api/v1beta4/databases/insert#request-body.
  :type body: dict
  :param project_id: Project ID of the project that contains the instance. If set
  to None or missing, the default project_id from the GCP connection is used.
  :type project_id: str
  :return: None","def foo(self, instance, database, body, project_id=None):
  
  response = self.get_conn().databases().patch(
  project=project_id,
  instance=instance,
  database=database,
  body=body
  ).execute(num_retries=self.num_retries)
  operation_name = response[""name""]
  self._wait_for_operation_to_complete(project_id=project_id,
  operation_name=operation_name)",This function updates a database entry using a patch request and waits for the operation to complete before returning.
"Deletes a database from a Cloud SQL instance.
 
  :param instance: Database instance ID. This does not include the project ID.
  :type instance: str
  :param database: Name of the database to be deleted in the instance.
  :type database: str
  :param project_id: Project ID of the project that contains the instance. If set
  to None or missing, the default project_id from the GCP connection is used.
  :type project_id: str
  :return: None","def foo(self, instance, database, project_id=None):
  
  response = self.get_conn().databases().delete(
  project=project_id,
  instance=instance,
  database=database
  ).execute(num_retries=self.num_retries)
  operation_name = response[""name""]
  self._wait_for_operation_to_complete(project_id=project_id,
  operation_name=operation_name)","This function deletes a database from a cloud instance and waits until the operation completes.
"
"Exports data from a Cloud SQL instance to a Cloud Storage bucket as a SQL dump
  or CSV file.
 
  :param instance: Database instance ID of the Cloud SQL instance. This does not include the
  project ID.
  :type instance: str
  :param body: The request body, as described in
  https://cloud.google.com/sql/docs/mysql/admin-api/v1beta4/instances/export#request-body
  :type body: dict
  :param project_id: Project ID of the project that contains the instance. If set
  to None or missing, the default project_id from the GCP connection is used.
  :type project_id: str
  :return: None","def foo(self, instance, body, project_id=None):
  
  try:
  response = self.get_conn().instances().export(
  project=project_id,
  instance=instance,
  body=body
  ).execute(num_retries=self.num_retries)
  operation_name = response[""name""]
  self._wait_for_operation_to_complete(project_id=project_id,
  operation_name=operation_name)
  except HttpError as ex:
  raise AirflowException(
  'Exporting instance {} failed: {}'.format(instance, ex.content)
  )","This function exports a database instance, waits for the operation to complete, and handles any resulting HTTP errors."
"Starts Cloud SQL Proxy.
 
  You have to remember to stop the proxy if you started it!","def foo(self):
  
  self._download_sql_proxy_if_needed()
  if self.sql_proxy_process:
  raise AirflowException(""The sql proxy is already running: {}"".format(
  self.sql_proxy_process))
  else:
  command_to_run = [self.sql_proxy_path]
  command_to_run.extend(self.command_line_parameters)
  try:
  self.log.info(""Creating directory %s"",
  self.cloud_sql_proxy_socket_directory)
  os.makedirs(self.cloud_sql_proxy_socket_directory)
  except OSError:
  
  pass
  command_to_run.extend(self._get_credential_parameters())
  self.log.info(""Running the command: `%s`"", "" "".join(command_to_run))
  self.sql_proxy_process = Popen(command_to_run,
  stdin=PIPE, stdout=PIPE, stderr=PIPE)
  self.log.info(""The pid of cloud_sql_proxy: %s"", self.sql_proxy_process.pid)
  while True:
  line = self.sql_proxy_process.stderr.readline().decode('utf-8')
  return_code = self.sql_proxy_process.poll()
  if line == '' and return_code is not None:
  self.sql_proxy_process = None
  raise AirflowException(
  ""The cloud_sql_proxy finished early with return code {}!"".format(
  return_code))
  if line != '':
  self.log.info(line)
  if ""googleapi: Error"" in line or ""invalid instance name:"" in line:
  self.stop_proxy()
  raise AirflowException(
  ""Error when starting the cloud_sql_proxy {}!"".format(
  line))
  if ""Ready for new connections"" in line:
  return","This function manages the startup of a SQL proxy, checks if it's already running, creates necessary directories, and logs the proxy's output until it's ready for new connections."
"Stops running proxy.
 
  You should stop the proxy after you stop using it.","def foo(self):
  
  if not self.sql_proxy_process:
  raise AirflowException(""The sql proxy is not started yet"")
  else:
  self.log.info(""Stopping the cloud_sql_proxy pid: %s"",
  self.sql_proxy_process.pid)
  self.sql_proxy_process.kill()
  self.sql_proxy_process = None
  
  self.log.info(""Removing the socket directory: %s"",
  self.cloud_sql_proxy_socket_directory)
  shutil.rmtree(self.cloud_sql_proxy_socket_directory, ignore_errors=True)
  if self.sql_proxy_was_downloaded:
  self.log.info(""Removing downloaded proxy: %s"", self.sql_proxy_path)
  
  try:
  os.remove(self.sql_proxy_path)
  except OSError as e:
  if not e.errno == errno.ENOENT:
  raise
  else:
  self.log.info(""Skipped removing proxy - it was not downloaded: %s"",
  self.sql_proxy_path)
  if os.path.isfile(self.credentials_path):
  self.log.info(""Removing generated credentials file %s"",
  self.credentials_path)
  
  os.remove(self.credentials_path)","This function terminates an SQL proxy process, cleans up related directories and files, and handles potential errors during removal."
Returns version of the Cloud SQL Proxy.,"def foo(self):
  
  self._download_sql_proxy_if_needed()
  command_to_run = [self.sql_proxy_path]
  command_to_run.extend(['--version'])
  command_to_run.extend(self._get_credential_parameters())
  result = subprocess.check_output(command_to_run).decode('utf-8')
  pattern = re.compile(""^.*[V|v]ersion ([^;]*);.*$"")
  m = pattern.match(result)
  if m:
  return m.group(1)
  else:
  return None",This function checks the version of an SQL proxy by executing a command and parsing the output with a regex pattern.
"Create connection in the Connection table, according to whether it uses
  proxy, TCP, UNIX sockets, SSL. Connection ID will be randomly generated.
 
  :param session: Session of the SQL Alchemy ORM (automatically generated with
  decorator).","def foo(self, session=None):
  
  connection = Connection(conn_id=self.db_conn_id)
  uri = self._generate_connection_uri()
  self.log.info(""Creating connection %s"", self.db_conn_id)
  connection.parse_from_uri(uri)
  session.add(connection)
  session.commit()","This function establishes a database connection using a predefined connection ID, logs this event, and commits the new connection to the session."
"Retrieves the dynamically created connection from the Connection table.
 
  :param session: Session of the SQL Alchemy ORM (automatically generated with
  decorator).","def foo(self, session=None):
  
  self.log.info(""Retrieving connection %s"", self.db_conn_id)
  connections = session.query(Connection).filter(
  Connection.conn_id == self.db_conn_id)
  if connections.count():
  return connections[0]
  return None","This function retrieves the first database connection with a specific ID from the provided session if available, or returns None otherwise."
"Delete the dynamically created connection from the Connection table.
 
  :param session: Session of the SQL Alchemy ORM (automatically generated with
  decorator).","def foo(self, session=None):
  
  self.log.info(""Deleting connection %s"", self.db_conn_id)
  connections = session.query(Connection).filter(
  Connection.conn_id == self.db_conn_id)
  if connections.count():
  connection = connections[0]
  session.delete(connection)
  session.commit()
  else:
  self.log.info(""Connection was already deleted!"")","This function removes a database connection from a session if it exists, otherwise logs that it was already deleted."
"Retrieve Cloud SQL Proxy runner. It is used to manage the proxy
  lifecycle per task.
 
  :return: The Cloud SQL Proxy runner.
  :rtype: CloudSqlProxyRunner","def foo(self):
  
  if not self.use_proxy:
  raise AirflowException(""Proxy runner can only be retrieved in case of use_proxy = True"")
  return CloudSqlProxyRunner(
  path_prefix=self.sql_proxy_unique_path,
  instance_specification=self._get_sqlproxy_instance_specification(),
  project_id=self.project_id,
  sql_proxy_version=self.sql_proxy_version,
  sql_proxy_binary_path=self.sql_proxy_binary_path
  )",This function raises an exception if proxy usage is not enabled and otherwise returns a configured instance of CloudSqlProxyRunner.
"Retrieve database hook. This is the actual Postgres or MySQL database hook
  that uses proxy or connects directly to the Google Cloud SQL database.","def foo(self):
  
  if self.database_type == 'postgres':
  self.db_hook = PostgresHook(postgres_conn_id=self.db_conn_id,
  schema=self.database)
  else:
  self.db_hook = MySqlHook(mysql_conn_id=self.db_conn_id,
  schema=self.database)
  return self.db_hook",This function initializes a database connection hook based on the type of database defined in the object's properties.
Clean up database hook after it was used.,"def foo(self):
  
  if self.database_type == 'postgres':
  if hasattr(self.db_hook,
  'conn') and self.db_hook.conn and self.db_hook.conn.notices:
  for output in self.db_hook.conn.notices:
  self.log.info(output)",This function checks if the database type is PostgreSQL and logs any notices present in the database connection.
Reserve free TCP port to be used by Cloud SQL Proxy,"def foo(self):
  
  self.reserved_tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  self.reserved_tcp_socket.bind(('127.0.0.1', 0))
  self.sql_proxy_tcp_port = self.reserved_tcp_socket.getsockname()[1]","This function creates a TCP socket bound to the localhost IP and an available random port, then stores the assigned port number."
"Replaces invalid MLEngine job_id characters with '_'.
 
  This also adds a leading 'z' in case job_id starts with an invalid
  character.
 
  Args:
  job_id: A job_id str that may have invalid characters.
 
  Returns:
  A valid job_id representation.","def foo(job_id):
  
 
  
  match = re.search(r'\d|\{{2}', job_id)
  if match and match.start() == 0:
  job = 'z_{}'.format(job_id)
  else:
  job = job_id
 
  
  tracker = 0
  cleansed_job_id = ''
  for m in re.finditer(r'\{{2}.+?\}{2}', job):
  cleansed_job_id += re.sub(r'[^0-9a-zA-Z]+', '_',
  job[tracker:m.start()])
  cleansed_job_id += job[m.start():m.end()]
  tracker = m.end()
 
  
  cleansed_job_id += re.sub(r'[^0-9a-zA-Z]+', '_', job[tracker:])
 
  return cleansed_job_id","This function processes string identifiers, prefixes certain cases with 'z_', and cleanses them by replacing non-alphanumeric characters with underscores while retaining double curly brace blocks."
Extract error code from ftp exception,"def foo(self, e):
  
  try:
  matches = self.error_code_pattern.match(str(e))
  code = int(matches.group(0))
  return code
  except ValueError:
  return e","This function attempts to extract an error code from an exception message using a pattern match, returning the code or the original exception on failure."
Remove any existing DAG runs for the perf test DAGs.,"def foo():
  
  session = settings.Session()
  drs = session.query(DagRun).filter(
  DagRun.dag_id.in_(DAG_IDS),
  ).all()
  for dr in drs:
  logging.info('Deleting DagRun :: {}'.format(dr))
  session.delete(dr)","This function retrieves all DagRun records for specific DAG IDs from the database and deletes them, logging each deletion."
Remove any existing task instances for the perf test DAGs.,"def foo():
  
  session = settings.Session()
  TI = TaskInstance
  tis = (
  session
  .query(TI)
  .filter(TI.dag_id.in_(DAG_IDS))
  .all()
  )
  for ti in tis:
  logging.info('Deleting TaskInstance :: {}'.format(ti))
  session.delete(ti)
  session.commit()","This function queries a database for TaskInstances matching certain DAG IDs, logs their details, and then deletes them from the session."
Toggle the pause state of the DAGs in the test.,"def foo(is_paused):
  
  session = settings.Session()
  dms = session.query(DagModel).filter(
  DagModel.dag_id.in_(DAG_IDS))
  for dm in dms:
  logging.info('Setting DAG :: {} is_paused={}'.format(dm, is_paused))
  dm.is_paused = is_paused
  session.commit()",This function updates the pause status of specified DAGs in a database using an ORM session.
Override the scheduler heartbeat to determine when the test is complete,"def foo(self):
  
  super(SchedulerMetricsJob, self).heartbeat()
  session = settings.Session()
  
  TI = TaskInstance
  successful_tis = (
  session
  .query(TI)
  .filter(TI.dag_id.in_(DAG_IDS))
  .filter(TI.state.in_([State.SUCCESS]))
  .all()
  )
  session.commit()
 
  dagbag = DagBag(SUBDIR)
  dags = [dagbag.dags[dag_id] for dag_id in DAG_IDS]
  
  num_task_instances = sum([(timezone.utcnow() - task.start_date).days
  for dag in dags for task in dag.tasks])
 
  if (len(successful_tis) == num_task_instances or
  (timezone.utcnow() - self.start_date).total_seconds() >
  MAX_RUNTIME_SECS):
  if len(successful_tis) == num_task_instances:
  self.log.info(""All tasks processed! Printing stats."")
  else:
  self.log.info(""Test timeout reached. Printing available stats."")
  self.print_stats()
  set_dags_paused_state(True)
  sys.exit()","This function updates metrics, fetches successful task instances, checks if all tasks are processed or timeout occurred, logs stats, pauses DAGs, and exits the script."
Invoke Lambda Function,"def foo(self, payload):
  
 
  awslambda_conn = self.get_conn()
 
  response = awslambda_conn.invoke(
  FunctionName=self.function_name,
  InvocationType=self.invocation_type,
  LogType=self.log_type,
  Payload=payload,
  Qualifier=self.qualifier
  )
 
  return response",This function invokes an AWS Lambda function with specified parameters and returns the response from the invocation.
"Creates Operators needed for model evaluation and returns.
 
  It gets prediction over inputs via Cloud ML Engine BatchPrediction API by
  calling MLEngineBatchPredictionOperator, then summarize and validate
  the result via Cloud Dataflow using DataFlowPythonOperator.
 
  For details and pricing about Batch prediction, please refer to the website
  https://cloud.google.com/ml-engine/docs/how-tos/batch-predict
  and for Cloud Dataflow, https://cloud.google.com/dataflow/docs/
 
  It returns three chained operators for prediction, summary, and validation,
  named as <prefix>-prediction, <prefix>-summary, and <prefix>-validation,
  respectively.
  (<prefix> should contain only alphanumeric characters or hyphen.)
 
  The upstream and downstream can be set accordingly like:
  pred, _, val = create_evaluate_ops(...)
  pred.set_upstream(upstream_op)
  ...
  downstream_op.set_upstream(val)
 
  Callers will provide two python callables, metric_fn and validate_fn, in
  order to customize the evaluation behavior as they wish.
  - metric_fn receives a dictionary per instance derived from json in the
  batch prediction result. The keys might vary depending on the model.
  It should return a tuple of metrics.
  - validation_fn receives a dictionary of the averaged metrics that metric_fn
  generated over all instances.
  The key/value of the dictionary matches to what's given by
  metric_fn_and_keys arg.
  The dictionary contains an additional metric, 'count' to represent the
  total number of instances received for evaluation.
  The function would raise an exception to mark the task as failed, in a
  case the validation result is not okay to proceed (i.e. to set the trained
  version as default).
 
  Typical examples are like this:
 
  def get_metric_fn_and_keys():
  import math # imports should be outside of the metric_fn below.
  def error_and_squared_error(inst):
  label = float(inst['input_label'])
  classes = float(inst['classes']) # 0 or 1
  err = abs(classes-label)
  squared_err = math.pow(classes-label, 2)
  return (err, squared_err) # returns a tuple.
  return error_and_squared_error, ['err', 'mse'] # key order must match.
 
  def validate_err_and_count(summary):
  if summary['err'] > 0.2:
  raise ValueError('Too high err>0.2; summary=%s' % summary)
  if summary['mse'] > 0.05:
  raise ValueError('Too high mse>0.05; summary=%s' % summary)
  if summary['count'] < 1000:
  raise ValueError('Too few instances<1000; summary=%s' % summary)
  return summary
 
  For the details on the other BatchPrediction-related arguments (project_id,
  job_id, region, data_format, input_paths, prediction_path, model_uri),
  please refer to MLEngineBatchPredictionOperator too.
 
  :param task_prefix: a prefix for the tasks. Only alphanumeric characters and
  hyphen are allowed (no underscores), since this will be used as dataflow
  job name, which doesn't allow other characters.
  :type task_prefix: str
 
  :param data_format: either of 'TEXT', 'TF_RECORD', 'TF_RECORD_GZIP'
  :type data_format: str
 
  :param input_paths: a list of input paths to be sent to BatchPrediction.
  :type input_paths: list[str]
 
  :param prediction_path: GCS path to put the prediction results in.
  :type prediction_path: str
 
  :param metric_fn_and_keys: a tuple of metric_fn and metric_keys:
  - metric_fn is a function that accepts a dictionary (for an instance),
  and returns a tuple of metric(s) that it calculates.
  - metric_keys is a list of strings to denote the key of each metric.
  :type metric_fn_and_keys: tuple of a function and a list[str]
 
  :param validate_fn: a function to validate whether the averaged metric(s) is
  good enough to push the model.
  :type validate_fn: function
 
  :param batch_prediction_job_id: the id to use for the Cloud ML Batch
  prediction job. Passed directly to the MLEngineBatchPredictionOperator as
  the job_id argument.
  :type batch_prediction_job_id: str
 
  :param project_id: the Google Cloud Platform project id in which to execute
  Cloud ML Batch Prediction and Dataflow jobs. If None, then the `dag`'s
  `default_args['project_id']` will be used.
  :type project_id: str
 
  :param region: the Google Cloud Platform region in which to execute Cloud ML
  Batch Prediction and Dataflow jobs. If None, then the `dag`'s
  `default_args['region']` will be used.
  :type region: str
 
  :param dataflow_options: options to run Dataflow jobs. If None, then the
  `dag`'s `default_args['dataflow_default_options']` will be used.
  :type dataflow_options: dictionary
 
  :param model_uri: GCS path of the model exported by Tensorflow using
  tensorflow.estimator.export_savedmodel(). It cannot be used with
  model_name or version_name below. See MLEngineBatchPredictionOperator for
  more detail.
  :type model_uri: str
 
  :param model_name: Used to indicate a model to use for prediction. Can be
  used in combination with version_name, but cannot be used together with
  model_uri. See MLEngineBatchPredictionOperator for more detail. If None,
  then the `dag`'s `default_args['model_name']` will be used.
  :type model_name: str
 
  :param version_name: Used to indicate a model version to use for prediction,
  in combination with model_name. Cannot be used together with model_uri.
  See MLEngineBatchPredictionOperator for more detail. If None, then the
  `dag`'s `default_args['version_name']` will be used.
  :type version_name: str
 
  :param dag: The `DAG` to use for all Operators.
  :type dag: airflow.models.DAG
 
  :returns: a tuple of three operators, (prediction, summary, validation)
  :rtype: tuple(DataFlowPythonOperator, DataFlowPythonOperator,
  PythonOperator)","def foo(task_prefix,
  data_format,
  input_paths,
  prediction_path,
  metric_fn_and_keys,
  validate_fn,
  batch_prediction_job_id=None,
  project_id=None,
  region=None,
  dataflow_options=None,
  model_uri=None,
  model_name=None,
  version_name=None,
  dag=None):
  
 
  
  
  if not re.match(r""^[a-zA-Z][-A-Za-z0-9]*$"", task_prefix):
  raise AirflowException(
  ""Malformed task_id for DataFlowPythonOperator (only alphanumeric ""
  ""and hyphens are allowed but got: "" + task_prefix)
 
  metric_fn, metric_keys = metric_fn_and_keys
  if not callable(metric_fn):
  raise AirflowException(""`metric_fn` param must be callable."")
  if not callable(validate_fn):
  raise AirflowException(""`validate_fn` param must be callable."")
 
  if dag is not None and dag.default_args is not None:
  default_args = dag.default_args
  project_id = project_id or default_args.get('project_id')
  region = region or default_args.get('region')
  model_name = model_name or default_args.get('model_name')
  version_name = version_name or default_args.get('version_name')
  dataflow_options = dataflow_options or \
  default_args.get('dataflow_default_options')
 
  evaluate_prediction = MLEngineBatchPredictionOperator(
  task_id=(task_prefix + ""-prediction""),
  project_id=project_id,
  job_id=batch_prediction_job_id,
  region=region,
  data_format=data_format,
  input_paths=input_paths,
  output_path=prediction_path,
  uri=model_uri,
  model_name=model_name,
  version_name=version_name,
  dag=dag)
 
  metric_fn_encoded = base64.b64encode(dill.dumps(metric_fn, recurse=True))
  evaluate_summary = DataFlowPythonOperator(
  task_id=(task_prefix + ""-summary""),
  py_options=[""-m""],
  py_file=""airflow.contrib.utils.mlengine_prediction_summary"",
  dataflow_default_options=dataflow_options,
  options={
  ""prediction_path"": prediction_path,
  ""metric_fn_encoded"": metric_fn_encoded,
  ""metric_keys"": ','.join(metric_keys)
  },
  dag=dag)
  evaluate_summary.set_upstream(evaluate_prediction)
 
  def apply_validate_fn(*args, **kwargs):
  prediction_path = kwargs[""templates_dict""][""prediction_path""]
  scheme, bucket, obj, _, _ = urlsplit(prediction_path)
  if scheme != ""gs"" or not bucket or not obj:
  raise ValueError(""Wrong format prediction_path: %s"",
  prediction_path)
  summary = os.path.join(obj.strip(""/""),
  ""prediction.summary.json"")
  gcs_hook = GoogleCloudStorageHook()
  summary = json.loads(gcs_hook.download(bucket, summary))
  return validate_fn(summary)
 
  evaluate_validation = PythonOperator(
  task_id=(task_prefix + ""-validation""),
  python_callable=apply_validate_fn,
  provide_context=True,
  templates_dict={""prediction_path"": prediction_path},
  dag=dag)
  evaluate_validation.set_upstream(evaluate_summary)
 
  return evaluate_prediction, evaluate_summary, evaluate_validation","This function sets up a data processing pipeline with specified validation for machine learning predictions, using Google Cloud services."
"Creates the directory specified by path, creating intermediate directories
  as necessary. If directory already exists, this is a no-op.
 
  :param path: The directory to create
  :type path: str
  :param mode: The mode to give to the directory e.g. 0o755, ignores umask
  :type mode: int","def foo(path, mode):
  
  try:
  o_umask = os.umask(0)
  os.makedirs(path, mode)
  except OSError:
  if not os.path.isdir(path):
  raise
  finally:
  os.umask(o_umask)","This function attempts to create a directory with a specified mode, handling concurrent creation and restoring the original umask setting."
"A small helper function to convert a string to a numeric value
  if appropriate
 
  :param s: the string to be converted
  :type s: str","def foo(s):
  
  try:
  ret = float(s)
  except (ValueError, TypeError):
  ret = s
  return ret","This function converts a string to a float, if possible, or returns the original string if conversion fails due to invalid input."
"Make a naive datetime.datetime in a given time zone aware.
 
  :param value: datetime
  :param timezone: timezone
  :return: localized datetime in settings.TIMEZONE or timezone","def foo(value, timezone=None):
  
  if timezone is None:
  timezone = TIMEZONE
 
  
  if is_localized(value):
  raise ValueError(
  ""foo expects a naive datetime, got %s"" % value)
  if hasattr(value, 'fold'):
  
  
  
  
  value = value.replace(fold=1)
  if hasattr(timezone, 'localize'):
  
  return timezone.localize(value)
  elif hasattr(timezone, 'convert'):
  
  return timezone.convert(value)
  else:
  
  return value.replace(tzinfo=timezone)","This function takes a naive datetime object and attaches a timezone to it, converting it into an aware datetime object if applicable."
"Make an aware datetime.datetime naive in a given time zone.
 
  :param value: datetime
  :param timezone: timezone
  :return: naive datetime","def foo(value, timezone=None):
  
  if timezone is None:
  timezone = TIMEZONE
 
  
  if is_naive(value):
  raise ValueError(""foo() cannot be applied to a naive datetime"")
 
  o = value.astimezone(timezone)
 
  
  naive = dt.datetime(o.year,
  o.month,
  o.day,
  o.hour,
  o.minute,
  o.second,
  o.microsecond)
 
  return naive","This function converts an aware datetime object to a naive datetime object in a specified or default timezone, raising an error if the input is naive."
"Wrapper around datetime.datetime that adds settings.TIMEZONE if tzinfo not specified
 
  :return: datetime.datetime","def foo(*args, **kwargs):
  
  if 'tzinfo' not in kwargs:
  kwargs['tzinfo'] = TIMEZONE
 
  return dt.foo(*args, **kwargs)","This function modifies the keyword arguments to include a specific timezone if it's not already provided, then calls another function with the updated arguments."
Establish a connection to druid broker.,"def foo(self):
  
  conn = self.get_connection(self.druid_broker_conn_id)
  druid_broker_conn = connect(
  host=conn.host,
  port=conn.port,
  path=conn.extra_dejson.get('endpoint', '/druid/v2/sql'),
  scheme=conn.extra_dejson.get('schema', 'http')
  )
  self.log.info('Get the connection to druid broker on %s', conn.host)
  return druid_broker_conn","This function establishes a connection to a Druid broker using specified host, port, and connection parameters, and logs the connection status."
"Returns http session for use with requests
 
  :param headers: additional headers to be passed through as a dictionary
  :type headers: dict","def foo(self, headers=None):
  
  session = requests.Session()
  if self.http_conn_id:
  conn = self.get_connection(self.http_conn_id)
 
  if ""://"" in conn.host:
  self.base_url = conn.host
  else:
  
  schema = conn.schema if conn.schema else ""http""
  self.base_url = schema + ""://"" + conn.host
 
  if conn.port:
  self.base_url = self.base_url + "":"" + str(conn.port)
  if conn.login:
  session.auth = (conn.login, conn.password)
  if conn.extra:
  try:
  session.headers.update(conn.extra_dejson)
  except TypeError:
  self.log.warn('Connection to %s has invalid extra field.', conn.host)
  if headers:
  session.headers.update(headers)
 
  return session","This function initializes a request session and configures its connection parameters including URL, authentication, and custom headers."
"Performs the request
 
  :param endpoint: the endpoint to be called i.e. resource/v1/query?
  :type endpoint: str
  :param data: payload to be uploaded or request parameters
  :type data: dict
  :param headers: additional headers to be passed through as a dictionary
  :type headers: dict
  :param extra_options: additional options to be used when executing the request
  i.e. {'check_response': False} to avoid checking raising exceptions on non
  2XX or 3XX status codes
  :type extra_options: dict","def foo(self, endpoint, data=None, headers=None, extra_options=None):
  
  extra_options = extra_options or {}
 
  session = self.get_conn(headers)
 
  if self.base_url and not self.base_url.endswith('/') and \
  endpoint and not endpoint.startswith('/'):
  url = self.base_url + '/' + endpoint
  else:
  url = (self.base_url or '') + (endpoint or '')
 
  req = None
  if self.method == 'GET':
  
  req = requests.Request(self.method,
  url,
  params=data,
  headers=headers)
  elif self.method == 'HEAD':
  
  req = requests.Request(self.method,
  url,
  headers=headers)
  else:
  
  req = requests.Request(self.method,
  url,
  data=data,
  headers=headers)
 
  prepped_request = session.prepare_request(req)
  self.log.info(""Sending '%s' to url: %s"", self.method, url)
  return self.run_and_check(session, prepped_request, extra_options)","This function prepares and sends an HTTP request using the specified method, endpoint, data, and headers, while handling base URL concatenation and logging the request info."
"Checks the status code and raise an AirflowException exception on non 2XX or 3XX
  status codes
 
  :param response: A requests response object
  :type response: requests.response","def foo(self, response):
  
  try:
  response.raise_for_status()
  except requests.exceptions.HTTPError:
  self.log.error(""HTTP error: %s"", response.reason)
  if self.method not in ['GET', 'HEAD']:
  self.log.error(response.text)
  raise AirflowException(str(response.status_code) + "":"" + response.reason)","This function checks if the HTTP response indicates an error and logs the issue, re-raising an exception for non-success statuses on certain request types."
"Grabs extra options like timeout and actually runs the request,
  checking for the result
 
  :param session: the session to be used to execute the request
  :type session: requests.Session
  :param prepped_request: the prepared request generated in run()
  :type prepped_request: session.prepare_request
  :param extra_options: additional options to be used when executing the request
  i.e. {'check_response': False} to avoid checking raising exceptions on non 2XX
  or 3XX status codes
  :type extra_options: dict","def foo(self, session, prepped_request, extra_options):
  
  extra_options = extra_options or {}
 
  try:
  response = session.send(
  prepped_request,
  stream=extra_options.get(""stream"", False),
  verify=extra_options.get(""verify"", True),
  proxies=extra_options.get(""proxies"", {}),
  cert=extra_options.get(""cert""),
  timeout=extra_options.get(""timeout""),
  allow_redirects=extra_options.get(""allow_redirects"", True))
 
  if extra_options.get('check_response', True):
  self.check_response(response)
  return response
 
  except requests.exceptions.ConnectionError as ex:
  self.log.warn(str(ex) + ' Tenacity will retry to execute the operation')
  raise ex","This function sends an HTTP request using the provided session and options, handles retries on connection errors, and optionally validates the response."
Contextmanager that will create and teardown a session.,"def foo():
  
  session = settings.Session()
  try:
  yield session
  session.commit()
  except Exception:
  session.rollback()
  raise
  finally:
  session.close()","This function establishes a database session, commits successful transactions, rolls back on exceptions, and ensures the session is closed afterwards."
"Function decorator that provides a session if it isn't provided.
  If you want to reuse a session or run the function as part of a
  database transaction, you pass it to the function, if not this wrapper
  will create one and close it for you.","def foo(func):
  
  @wraps(func)
  def wrapper(*args, **kwargs):
  arg_session = 'session'
 
  func_params = func.__code__.co_varnames
  session_in_args = arg_session in func_params and \
  func_params.index(arg_session) < len(args)
  session_in_kwargs = arg_session in kwargs
 
  if session_in_kwargs or session_in_args:
  return func(*args, **kwargs)
  else:
  with create_session() as session:
  kwargs[arg_session] = session
  return func(*args, **kwargs)
 
  return wrapper",This function decorates another function to optionally inject a session object if it's not already provided in the arguments.
Clear out the database,"def foo():
  
  from airflow import models
 
  
  from alembic.migration import MigrationContext
 
  log.info(""Dropping tables that exist"")
 
  models.base.Base.metadata.drop_all(settings.engine)
  mc = MigrationContext.configure(settings.engine)
  if mc._version.exists(settings.engine):
  mc._version.drop(settings.engine)
 
  from flask_appbuilder.models.sqla import Base
  Base.metadata.drop_all(settings.engine)
 
  initdb()","This function removes all tables managed by Airflow and Flask-AppBuilder from the database, resets the Alembic migration state, and then reinitializes the database."
Parses some DatabaseError to provide a better error message,"def foo(e):
  
  if (hasattr(e, 'message') and
  'errorName' in e.message and
  'message' in e.message):
  return ('{name}: {message}'.format(
  name=e.message['errorName'],
  message=e.message['message']))
  else:
  return str(e)","This function formats the error message from an exception object's 'message' attribute if it meets specific criteria, or converts the exception to a string otherwise."
Get a set of records from Presto,"def foo(self, hql, parameters=None):
  
  try:
  return super().get_records(
  self._strip_sql(hql), parameters)
  except DatabaseError as e:
  raise PrestoException(self._get_pretty_exception_message(e))","This function executes a provided Hive query, handling any database errors by raising a custom PrestoException with a formatted message."
Get a pandas dataframe from a sql query.,"def foo(self, hql, parameters=None):
  
  import pandas
  cursor = self.get_cursor()
  try:
  cursor.execute(self._strip_sql(hql), parameters)
  data = cursor.fetchall()
  except DatabaseError as e:
  raise PrestoException(self._get_pretty_exception_message(e))
  column_descriptions = cursor.description
  if data:
  df = pandas.DataFrame(data)
  df.columns = [c[0] for c in column_descriptions]
  else:
  df = pandas.DataFrame()
  return df","This function executes a query, retrieves the results, and converts them to a pandas DataFrame with columns named after the query result schema."
Execute the statement against Presto. Can be used to create views.,"def foo(self, hql, parameters=None):
  
  return super().run(self._strip_sql(hql), parameters)","This function executes a modified SQL query using a parent class method, with optional parameters."
"A generic way to insert a set of tuples into a table.
 
  :param table: Name of the target table
  :type table: str
  :param rows: The rows to insert into the table
  :type rows: iterable of tuples
  :param target_fields: The names of the columns to fill in the table
  :type target_fields: iterable of strings","def foo(self, table, rows, target_fields=None):
  
  super().insert_rows(table, rows, target_fields, 0)",This function extends a method from its superclass to insert rows into a specified table without retries.
Return a cosmos db client.,"def foo(self):
  
  if self.cosmos_client is not None:
  return self.cosmos_client
 
  
  self.cosmos_client = cosmos_client.CosmosClient(self.endpoint_uri, {'masterKey': self.master_key})
 
  return self.cosmos_client",This function returns an existing CosmosDB client instance or creates and returns a new one if it doesn't exist.
Checks if a collection exists in CosmosDB.,"def foo(self, collection_name, database_name=None):
  
  if collection_name is None:
  raise AirflowBadRequest(""Collection name cannot be None."")
 
  existing_container = list(self.get_conn().QueryContainers(
  get_database_link(self.__get_database_name(database_name)), {
  ""query"": ""SELECT * FROM r WHERE r.id=@id"",
  ""parameters"": [
  {""name"": ""@id"", ""value"": collection_name}
  ]
  }))
  if len(existing_container) == 0:
  return False
 
  return True","This function checks if a specific collection exists within a given or default database, returning `True` if it exists or `False` otherwise."
Creates a new collection in the CosmosDB database.,"def foo(self, collection_name, database_name=None):
  
  if collection_name is None:
  raise AirflowBadRequest(""Collection name cannot be None."")
 
  
  
  existing_container = list(self.get_conn().QueryContainers(
  get_database_link(self.__get_database_name(database_name)), {
  ""query"": ""SELECT * FROM r WHERE r.id=@id"",
  ""parameters"": [
  {""name"": ""@id"", ""value"": collection_name}
  ]
  }))
 
  
  if len(existing_container) == 0:
  self.get_conn().CreateContainer(
  get_database_link(self.__get_database_name(database_name)),
  {""id"": collection_name})",This function checks if a specified collection exists within a database and creates it if not found.
Checks if a database exists in CosmosDB.,"def foo(self, database_name):
  
  if database_name is None:
  raise AirflowBadRequest(""Database name cannot be None."")
 
  existing_database = list(self.get_conn().QueryDatabases({
  ""query"": ""SELECT * FROM r WHERE r.id=@id"",
  ""parameters"": [
  {""name"": ""@id"", ""value"": database_name}
  ]
  }))
  if len(existing_database) == 0:
  return False
 
  return True","This function checks if a database with a specified name exists in a connected data source, raising an exception if the name is not provided."
Creates a new database in CosmosDB.,"def foo(self, database_name):
  
  if database_name is None:
  raise AirflowBadRequest(""Database name cannot be None."")
 
  
  
  existing_database = list(self.get_conn().QueryDatabases({
  ""query"": ""SELECT * FROM r WHERE r.id=@id"",
  ""parameters"": [
  {""name"": ""@id"", ""value"": database_name}
  ]
  }))
 
  
  if len(existing_database) == 0:
  self.get_conn().CreateDatabase({""id"": database_name})","This function checks whether a database exists and creates it if not, raising an error if the database name is not provided."
Deletes an existing database in CosmosDB.,"def foo(self, database_name):
  
  if database_name is None:
  raise AirflowBadRequest(""Database name cannot be None."")
 
  self.get_conn().DeleteDatabase(get_database_link(database_name))","This function deletes a specified database, raising an exception if the database name is not provided."
Deletes an existing collection in the CosmosDB database.,"def foo(self, collection_name, database_name=None):
  
  if collection_name is None:
  raise AirflowBadRequest(""Collection name cannot be None."")
 
  self.get_conn().DeleteContainer(
  get_collection_link(self.__get_database_name(database_name), collection_name))","This function deletes a specified container (collection) from a database, and raises an error if the collection name is not provided."
Insert a list of new documents into an existing collection in the CosmosDB database.,"def foo(self, documents, database_name=None, collection_name=None):
  
  if documents is None:
  raise AirflowBadRequest(""You cannot insert empty documents"")
 
  created_documents = []
  for single_document in documents:
  created_documents.append(
  self.get_conn().CreateItem(
  get_collection_link(
  self.__get_database_name(database_name),
  self.__get_collection_name(collection_name)),
  single_document))
 
  return created_documents","This function inserts multiple documents into a specified collection within a database, raising an error if the documents list is empty."
Delete an existing document out of a collection in the CosmosDB database.,"def foo(self, document_id, database_name=None, collection_name=None):
  
  if document_id is None:
  raise AirflowBadRequest(""Cannot delete a document without an id"")
 
  self.get_conn().DeleteItem(
  get_document_link(
  self.__get_database_name(database_name),
  self.__get_collection_name(collection_name),
  document_id))","This function deletes a specified document from a database, raising an error if the document ID is not provided."
Get a document from an existing collection in the CosmosDB database.,"def foo(self, document_id, database_name=None, collection_name=None):
  
  if document_id is None:
  raise AirflowBadRequest(""Cannot get a document without an id"")
 
  try:
  return self.get_conn().ReadItem(
  get_document_link(
  self.__get_database_name(database_name),
  self.__get_collection_name(collection_name),
  document_id))
  except HTTPFailure:
  return None","This function retrieves a document from a database collection by its ID, returning `None` if an error occurs during retrieval."
Get a list of documents from an existing collection in the CosmosDB database via SQL query.,"def foo(self, sql_string, database_name=None, collection_name=None, partition_key=None):
  
  if sql_string is None:
  raise AirflowBadRequest(""SQL query string cannot be None"")
 
  
  query = {'query': sql_string}
 
  try:
  result_iterable = self.get_conn().QueryItems(
  get_collection_link(
  self.__get_database_name(database_name),
  self.__get_collection_name(collection_name)),
  query,
  partition_key)
 
  return list(result_iterable)
  except HTTPFailure:
  return None","This function executes a SQL query on a specified database collection and returns the results as a list, handling exceptions by returning None."
"Returns the Cloud Function with the given name.
 
  :param name: Name of the function.
  :type name: str
  :return: A Cloud Functions object representing the function.
  :rtype: dict","def foo(self, name):
  
  return self.get_conn().projects().locations().functions().get(
  name=name).execute(num_retries=self.num_retries)","This function retrieves a cloud function's details by name using an API connection, with a specified number of retries for the request."
"Creates a new function in Cloud Function in the location specified in the body.
 
  :param location: The location of the function.
  :type location: str
  :param body: The body required by the Cloud Functions insert API.
  :type body: dict
  :param project_id: Optional, Google Cloud Project project_id where the function belongs.
  If set to None or missing, the default project_id from the GCP connection is used.
  :type project_id: str
  :return: None","def foo(self, location, body, project_id=None):
  
  response = self.get_conn().projects().locations().functions().create(
  location=self._full_location(project_id, location),
  body=body
  ).execute(num_retries=self.num_retries)
  operation_name = response[""name""]
  self._wait_for_operation_to_complete(operation_name=operation_name)",This function creates a new cloud function in a specified location and waits for the operation to complete.
"Updates Cloud Functions according to the specified update mask.
 
  :param name: The name of the function.
  :type name: str
  :param body: The body required by the cloud function patch API.
  :type body: dict
  :param update_mask: The update mask - array of fields that should be patched.
  :type update_mask: [str]
  :return: None","def foo(self, name, body, update_mask):
  
  response = self.get_conn().projects().locations().functions().patch(
  updateMask="","".join(update_mask),
  name=name,
  body=body
  ).execute(num_retries=self.num_retries)
  operation_name = response[""name""]
  self._wait_for_operation_to_complete(operation_name=operation_name)","This function updates a Google Cloud Function, waits for the operation to complete, and handles retries."
"Uploads zip file with sources.
 
  :param location: The location where the function is created.
  :type location: str
  :param zip_path: The path of the valid .zip file to upload.
  :type zip_path: str
  :param project_id: Optional, Google Cloud Project project_id where the function belongs.
  If set to None or missing, the default project_id from the GCP connection is used.
  :type project_id: str
  :return: The upload URL that was returned by generateUploadUrl method.","def foo(self, location, zip_path, project_id=None):
  
  response = self.get_conn().projects().locations().functions().generateUploadUrl(
  parent=self._full_location(project_id, location)
  ).execute(num_retries=self.num_retries)
  upload_url = response.get('uploadUrl')
  with open(zip_path, 'rb') as fp:
  requests.put(
  url=upload_url,
  data=fp,
  
  
  
  headers={
  'Content-type': 'application/zip',
  'x-goog-content-length-range': '0,104857600',
  }
  )
  return upload_url",This function uploads a zip file to a generated URL for a cloud function within the given project and location.
"Deletes the specified Cloud Function.
 
  :param name: The name of the function.
  :type name: str
  :return: None","def foo(self, name):
  
  response = self.get_conn().projects().locations().functions().delete(
  name=name).execute(num_retries=self.num_retries)
  operation_name = response[""name""]
  self._wait_for_operation_to_complete(operation_name=operation_name)",This function invokes an API to delete a cloud function and waits for the operation to complete.
"Wrapper around the private _get_dep_statuses method that contains some global
  checks for all dependencies.
 
  :param ti: the task instance to get the dependency status for
  :type ti: airflow.models.TaskInstance
  :param session: database session
  :type session: sqlalchemy.orm.session.Session
  :param dep_context: the context for which this dependency should be evaluated for
  :type dep_context: DepContext","def foo(self, ti, session, dep_context=None):
  
  
  from airflow.ti_deps.dep_context import DepContext
 
  if dep_context is None:
  dep_context = DepContext()
 
  if self.IGNOREABLE and dep_context.ignore_all_deps:
  yield self._passing_status(
  reason=""Context specified all dependencies should be ignored."")
  return
 
  if self.IS_TASK_DEP and dep_context.ignore_task_deps:
  yield self._passing_status(
  reason=""Context specified all task dependencies should be ignored."")
  return
 
  for dep_status in self._get_dep_statuses(ti, session, dep_context):
  yield dep_status","This function yields dependency statuses for a task instance, allowing for certain dependency checks to be ignored based on the context provided."
"Returns whether or not this dependency is met for a given task instance. A
  dependency is considered met if all of the dependency statuses it reports are
  passing.
 
  :param ti: the task instance to see if this dependency is met for
  :type ti: airflow.models.TaskInstance
  :param session: database session
  :type session: sqlalchemy.orm.session.Session
  :param dep_context: The context this dependency is being checked under that stores
  state that can be used by this dependency.
  :type dep_context: BaseDepContext","def foo(self, ti, session, dep_context=None):
  
  return all(status.passed for status in
  self.get_dep_statuses(ti, session, dep_context))","This function checks if all dependency statuses for a given task instance have passed, returning a boolean result."
"Returns an iterable of strings that explain why this dependency wasn't met.
 
  :param ti: the task instance to see if this dependency is met for
  :type ti: airflow.models.TaskInstance
  :param session: database session
  :type session: sqlalchemy.orm.session.Session
  :param dep_context: The context this dependency is being checked under that stores
  state that can be used by this dependency.
  :type dep_context: BaseDepContext","def foo(self, ti, session, dep_context=None):
  
  for dep_status in self.get_dep_statuses(ti, session, dep_context):
  if not dep_status.passed:
  yield dep_status.reason",This function iterates through dependency statuses and yields reasons for any that haven't passed.
"Parses a config file for s3 credentials. Can currently
  parse boto, s3cmd.conf and AWS SDK config formats
 
  :param config_file_name: path to the config file
  :type config_file_name: str
  :param config_format: config type. One of ""boto"", ""s3cmd"" or ""aws"".
  Defaults to ""boto""
  :type config_format: str
  :param profile: profile name in AWS type config file
  :type profile: str","def foo(config_file_name, config_format='boto', profile=None):
  
  config = configparser.ConfigParser()
  if config.read(config_file_name): 
  sections = config.sections()
  else:
  raise AirflowException(""Couldn't read {0}"".format(config_file_name))
  
  if config_format is None:
  config_format = 'boto'
  conf_format = config_format.lower()
  if conf_format == 'boto': 
  if profile is not None and 'profile ' + profile in sections:
  cred_section = 'profile ' + profile
  else:
  cred_section = 'Credentials'
  elif conf_format == 'aws' and profile is not None:
  cred_section = profile
  else:
  cred_section = 'default'
  
  if conf_format in ('boto', 'aws'): 
  key_id_option = 'aws_access_key_id'
  secret_key_option = 'aws_secret_access_key'
  
  else:
  key_id_option = 'access_key'
  secret_key_option = 'secret_key'
  
  if cred_section not in sections:
  raise AirflowException(""This config file format is not recognized"")
  else:
  try:
  access_key = config.get(cred_section, key_id_option)
  secret_key = config.get(cred_section, secret_key_option)
  except Exception:
  logging.warning(""Option Error in parsing s3 config file"")
  raise
  return access_key, secret_key","This function reads a configuration file to retrieve AWS credentials, supporting different profiles and formats, and handles errors if the file or sections are not found."
"Get the underlying `botocore.Credentials` object.
 
  This contains the following authentication attributes: access_key, secret_key and token.","def foo(self, region_name=None):
  
  session, _ = self._get_credentials(region_name)
  
  
  
  return session.get_credentials().get_frozen_credentials()","This function retrieves AWS credentials, optionally for a specified region, and returns them in an immutable format."
Returns verticaql connection object,"def foo(self):
  
  conn = self.get_connection(self.vertica_conn_id)
  conn_config = {
  ""user"": conn.login,
  ""password"": conn.password or '',
  ""database"": conn.schema,
  ""host"": conn.host or 'localhost'
  }
 
  if not conn.port:
  conn_config[""port""] = 5433
  else:
  conn_config[""port""] = int(conn.port)
 
  conn = connect(**conn_config)
  return conn",This function establishes a connection to a Vertica database using provided connection details and returns the database connection object.
Ensure all logging output has been flushed,"def foo(self):
  
  if len(self._buffer) > 0:
  self.logger.log(self.level, self._buffer)
  self._buffer = str()","This function checks if a buffer is not empty, logs its contents, and then clears the buffer for future use."
"If the path contains a folder with a .zip suffix, then
  the folder is treated as a zip archive and path to zip is returned.","def foo(fileloc):
  
 
  _, archive, filename = re.search(
  r'((.*\.zip){})?(.*)'.format(re.escape(os.sep)), fileloc).groups()
  if archive and zipfile.is_zipfile(archive):
  return archive
  else:
  return fileloc","This function takes a file path, checks if it contains a .zip archive, and returns the archive path if present, otherwise returns the original path."
"Traverse a directory and look for Python files.
 
  :param directory: the directory to traverse
  :type directory: unicode
  :param safe_mode: whether to use a heuristic to determine whether a file
  contains Airflow DAG definitions
  :return: a list of paths to Python files in the specified directory
  :rtype: list[unicode]","def foo(directory, safe_mode=True,
  include_examples=None):
  
  if include_examples is None:
  include_examples = conf.getboolean('core', 'LOAD_EXAMPLES')
  file_paths = []
  if directory is None:
  return []
  elif os.path.isfile(directory):
  return [directory]
  elif os.path.isdir(directory):
  patterns_by_dir = {}
  for root, dirs, files in os.walk(directory, followlinks=True):
  patterns = patterns_by_dir.get(root, [])
  ignore_file = os.path.join(root, '.airflowignore')
  if os.path.isfile(ignore_file):
  with open(ignore_file, 'r') as f:
  
  
  patterns += [re.compile(p) for p in f.read().split('\n') if p]
 
  
  
  
  dirs[:] = [
  d
  for d in dirs
  if not any(p.search(os.path.join(root, d)) for p in patterns)
  ]
 
  
  
  for d in dirs:
  patterns_by_dir[os.path.join(root, d)] = patterns
 
  for f in files:
  try:
  file_path = os.path.join(root, f)
  if not os.path.isfile(file_path):
  continue
  mod_name, file_ext = os.path.splitext(
  os.path.split(file_path)[-1])
  if file_ext != '.py' and not zipfile.is_zipfile(file_path):
  continue
  if any([re.findall(p, file_path) for p in patterns]):
  continue
 
  
  
  might_contain_dag = True
  if safe_mode and not zipfile.is_zipfile(file_path):
  with open(file_path, 'rb') as fp:
  content = fp.read()
  might_contain_dag = all(
  [s in content for s in (b'DAG', b'airflow')])
 
  if not might_contain_dag:
  continue
 
  file_paths.append(file_path)
  except Exception:
  log = LoggingMixin().log
  log.exception(""Error while examining %s"", f)
  if include_examples:
  import airflow.example_dags
  example_dag_folder = airflow.example_dags.__path__[0]
  file_paths.extend(foo(example_dag_folder, safe_mode, False))
  return file_paths","This function scans a directory for Python files and ZIP archives, excluding ignored paths, and adds example DAGs if configured to do so."
"Construct a TaskInstance from the database based on the primary key
 
  :param session: DB session.
  :param lock_for_update: if True, indicates that the database should
  lock the TaskInstance (issuing a FOR UPDATE clause) until the
  session is committed.","def foo(self, session=None, lock_for_update=False):
  
  TI = airflow.models.TaskInstance
 
  qry = session.query(TI).filter(
  TI.dag_id == self._dag_id,
  TI.task_id == self._task_id,
  TI.execution_date == self._execution_date)
 
  if lock_for_update:
  ti = qry.with_for_update().first()
  else:
  ti = qry.first()
  return ti","This function retrieves the first task instance matching specific criteria from a database, optionally using a row-level lock."
Launch DagFileProcessorManager processor and start DAG parsing loop in manager.,"def foo(self):
  
  self._process = self._launch_process(self._dag_directory,
  self._file_paths,
  self._max_runs,
  self._processor_factory,
  self._child_signal_conn,
  self._stat_queue,
  self._result_queue,
  self._async_mode)
  self.log.info(""Launched DagFileProcessorManager with pid: %s"", self._process.pid)",This function initializes a subprocess for managing DAG file processing and logs the subprocess ID once launched.
This function runs an infinite loop that sends a termination message to a manager process and then breaks out of the loop.,"def foo(self):while (True):
  
  self.log.info(""Sending termination message to manager."")
  self._child_signal_conn.send(DagParsingSignal.TERMINATE_MANAGER)
 break",This function continuously sends a signal to terminate a manager process and then breaks the loop.
"This function handles the graceful termination of the program upon receiving a specific signal. It logs the signal received, terminates any ongoing processes, ends the program, and exits with a success status.","def foo(self, signum, frame):
  
  self.log.info(""Exiting gracefully upon receiving signal %s"", signum)
  self.terminate()
  self.end()
  self.log.debug(""Finished terminating DAG processors."")
  sys.exit(os.EX_OK)","This function handles a received signal by logging its occurrence, gracefully shutting down processes, and exiting the program with a successful status code."
"This function processes files using parallelism, checks for new files in a specified directory, and can be run in either synchronous or asynchronous mode. It logs various information about the processing parameters.","def foo(self):
  
 
  self.log.info(""Processing files using up to %s processes at a time "", self._parallelism)
  self.log.info(""Process each file at most once every %s seconds"", self._file_process_interval)
  self.log.info(
  ""Checking for new files in %s every %s seconds"", self._dag_directory, self.dag_dir_list_interval
  )
 
  if self._async_mode:
  self.log.debug(""Starting DagFileProcessorManager in async mode"")
  self.start_in_async()
  else: for ynzgcjahqazigtnfvtgavx in range(1):
  self.log.debug(""Starting DagFileProcessorManager in sync mode"")
  self.start_in_sync()",This function logs configuration settings and starts file processing in synchronous or asynchronous mode based on a condition.
"This function is responsible for running a loop that continuously checks for signals from an external process and performs various tasks based on those signals. It also refreshes the directory containing DAGs, sends heartbeats to the master, and maintains statistics. The loop continues until the maximum number of runs is reached or terminated by a signal.","def foo(self):
  
  while True:
  loop_start_time = time.time()
 
  if self._signal_conn.poll():
  agent_signal = self._signal_conn.recv()
  if agent_signal == DagParsingSignal.TERMINATE_MANAGER:
  self.terminate()
  break
  elif agent_signal == DagParsingSignal.END_MANAGER:
  self.end()
  sys.exit(os.EX_OK)
 
  self._refresh_dag_dir()
 
  simple_dags = self.heartbeat()
  for simple_dag in simple_dags: while (True):
  self._result_queue.put(simple_dag)
  break
 
  self._print_stat()
 
  all_files_processed = all(self.get_last_finish_time(x) is not None
  for x in self.file_paths)
  max_runs_reached = self.max_runs_reached()
 
  dag_parsing_stat = DagParsingStat(self._file_paths,
  self.get_all_pids(),
  max_runs_reached,
  all_files_processed,
  len(simple_dags))
  self._stat_queue.put(dag_parsing_stat)
 
  if max_runs_reached:
  self.log.info(""Exiting dag parsing loop as all files ""
  ""have been processed %s times"", self._max_runs)
  break
 
  loop_duration = time.time() - loop_start_time
  if loop_duration < 1:
  sleep_length = 1 - loop_duration
  self.log.debug(""Sleeping for %.2f seconds to prevent excessive logging"", sleep_length)
  time.sleep(sleep_length)","This function repeatedly checks for signals to manage the parsing process of DAG files, updates statistics, and exits when certain conditions are met."
"This function is the main loop for a dag parsing manager. It receives signals from agents, processes dag files, and sends the results to a queue. It also updates statistics and handles termination signals.","def foo(self):
  
  while True:
  agent_signal = self._signal_conn.recv()
  if agent_signal == DagParsingSignal.TERMINATE_MANAGER:
  self.terminate()
  break
  elif agent_signal == DagParsingSignal.END_MANAGER:
  self.end()
  sys.exit(os.EX_OK)
  elif agent_signal == DagParsingSignal.AGENT_HEARTBEAT:
 
  self._refresh_dag_dir()
 
  simple_dags = self.heartbeat()
  for simple_dag in simple_dags:
  self._result_queue.put(simple_dag)
 
  self._print_stat()
 
  all_files_processed = all(self.get_last_finish_time(x) is not None
  for x in self.file_paths)
  max_runs_reached = self.max_runs_reached()
 
  dag_parsing_stat = DagParsingStat(self._file_paths,
  self.get_all_pids(),
  self.max_runs_reached(),
  all_files_processed,
  len(simple_dags))
  self._stat_queue.put(dag_parsing_stat)
 
  self.wait_until_finished()
  self._signal_conn.send(DagParsingSignal.MANAGER_DONE)
 
  if max_runs_reached: while (True):
  self.log.info(""Exiting dag parsing loop as all files ""
  ""have been processed %s times"", self._max_runs)
  self._signal_conn.send(DagParsingSignal.MANAGER_DONE)
  break
  break","This function manages the life cycle of a DAG parsing workflow, handling signals for termination, completion, heartbeats, statistic collection, and process management within an infinite loop."
This function refreshes the list of file paths in the DAG directory if a certain time interval has passed. It also removes any old import errors.,"def foo(self):
  
  elapsed_time_since_refresh = (timezone.utcnow() -
  self.last_dag_dir_refresh_time).total_seconds()
  if elapsed_time_since_refresh > self.dag_dir_list_interval:
  
  self.log.info(""Searching for files in %s"", self._dag_directory)
  self._file_paths = list_py_file_paths(self._dag_directory)
  self.last_dag_dir_refresh_time = timezone.utcnow()
  self.log.info(""There are %s files in %s"", len(self._file_paths), self._dag_directory)
  self.set_file_paths(self._file_paths)
 
  try:
  self.log.debug(""Removing old import errors"")
  self.clear_nonexistent_import_errors()
  except Exception: for ynzgcjahqazigtnfvtgavx in range(1):
  self.log.exception(""Error removing old import errors"")",This function updates the list of files from a specific directory if a set interval has passed and clears errors from non-existent files.
"This function continuously checks if enough time has passed since the last statistics print. If so, it prints the processing statistics for a list of file paths.","def foo(self):while (True):
  
  if ((timezone.utcnow() - self.last_stat_print_time).total_seconds() >
  self.print_stats_interval):
  if len(self._file_paths) > 0:
  self._log_file_processing_stats(self._file_paths)
  self.last_stat_print_time = timezone.utcnow()
 break",This function continuously checks if the time interval has exceeded a threshold to log file processing stats and then updates the last printed time.
This function deletes ImportError objects from the database session for files that are not in the specified file paths.,"def foo(self, session):
  
  query = session.query(errors.ImportError)
  if self._file_paths:
  query = query.filter(
  ~errors.ImportError.filename.in_(self._file_paths)
  )
  query.delete(synchronize_session='fetch')
  session.commit()","This function deletes `ImportError` records that are not in a predefined list of file paths from a database, using a given database session."
"This function generates statistics for DAG file processing, including file path, PID, runtime, last runtime, and last run time for each file in a given list of known file paths. It also logs the statistics.","def foo(iBcAo, known_file_paths):
  
 
  
  
  
  
  
  
  
  
  headers = [""File Path"",
  ""PID"",
  ""Runtime"",
  ""Last Runtime"",
  ""Last Run""]
 
  rows = []
  for file_path in known_file_paths:
  last_runtime = iBcAo.get_last_runtime(file_path)
  file_name = os.path.basename(file_path)
  file_name = os.path.splitext(file_name)[0].replace(os.sep, '.')
  if last_runtime:
  Stats.gauge(
  'dag_processing.last_runtime.{}'.format(file_name),
  last_runtime
  )
 
  processor_pid = iBcAo.get_pid(file_path)
  processor_start_time = iBcAo.get_start_time(file_path)
  runtime = ((timezone.utcnow() - processor_start_time).total_seconds()
  if processor_start_time else None)
  last_run = iBcAo.get_last_finish_time(file_path)
  if last_run:
  seconds_ago = (timezone.utcnow() - last_run).total_seconds()
  Stats.gauge(
  'dag_processing.last_run.seconds_ago.{}'.format(file_name),
  seconds_ago
  )
 
  rows.append((file_path,
  processor_pid,
  runtime,
  last_runtime,
  last_run))
 
  
  rows = sorted(rows, key=lambda x: x[3] or 0.0)
 
  formatted_rows = []
  for file_path, pid, runtime, last_runtime, last_run in rows:
  formatted_rows.append((file_path,
  pid,
  ""{:.2f}s"".format(runtime)
  if runtime else None,
  ""{:.2f}s"".format(last_runtime)
  if last_runtime else None,
  last_run.strftime(""%Y-%m-%dT%H:%M:%S"")
  if last_run else None))
  log_str = (""\n"" +
  ""="" * 80 +
  ""\n"" +
  ""DAG File Processing Stats\n\n"" +
  tabulate(formatted_rows, headers=headers) +
  ""\n"" +
  ""="" * 80)
 
  iBcAo.log.info(log_str)","This function generates a log containing sorted processing statistics for a set of known file paths, formatted in a human-readable table form."
This function updates the list of file paths used by an object and filters out any file paths that are not in the new list. It also updates the dictionary of processors by removing any processors that are associated with file paths that are not in the new list.,"def foo(self, new_file_paths):
  
  self._file_paths = new_file_paths
  self._file_path_queue = [x for x in self._file_path_queue
  if x in new_file_paths]
  
  filtered_processors = {}
  for file_path, processor in self._processors.items():
  if file_path in new_file_paths:
  filtered_processors[file_path] = processor
  else:
  self.log.warning(""Stopping processor for %s"", file_path)
  to_destructive_ibex_engineer: str = ""iXI6Zie5CJGqej2a""
  processor.terminate()
  self._processors = filtered_processors","This function updates file paths, maintains a queue of valid paths, and terminates processors not associated with new paths, with logging for stopped processors."
This function waits for all the processors in the dictionary to finish their work before proceeding.,"def foo(self):
  
  for file_path, processor in self._processors.items():
  while not processor.done:
  time.sleep(0.1)","This function iterates over a dictionary of processors, pausing execution until each processor indicates it has completed its work."
"This function manages the execution of DAG parsing processes. It checks which processors have finished, collects the results, and queues new files for processing. It also handles zombies and manages the parallelism of the processors.","def foo(xe1iv):
  
  finished_processors = {}
  
  running_processors = {}
  
 
  for file_path, processor in xe1iv._processors.items():
  if processor.done:
  xe1iv.log.debug(""Processor for %s finished"", file_path)
  now = timezone.utcnow()
  finished_processors[file_path] = processor
  xe1iv._last_runtime[file_path] = (now -
  processor.start_time).total_seconds()
  xe1iv._last_finish_time[file_path] = now
  xe1iv._run_count[file_path] += 1
  else:
  running_processors[file_path] = processor
  xe1iv._processors = running_processors
 
  xe1iv.log.debug(""%s/%s DAG parsing processes running"",
  len(xe1iv._processors), xe1iv._parallelism)
 
  xe1iv.log.debug(""%s file paths queued for processing"",
  len(xe1iv._file_path_queue))
 
  
  simple_dags = []
  for file_path, processor in finished_processors.items():
  if processor.result is None:
  xe1iv.log.warning(
  ""Processor for %s exited with return code %s."",
  processor.file_path, processor.exit_code
  )
  else:
  for simple_dag in processor.result:
  simple_dags.append(simple_dag)
 
  
  
  if len(xe1iv._file_path_queue) == 0:
  
  
  file_paths_in_progress = xe1iv._processors.keys()
  now = timezone.utcnow()
  file_paths_recently_processed = []
  for file_path in xe1iv._file_paths:
  last_finish_time = xe1iv.get_last_finish_time(file_path)
  if (last_finish_time is not None and
  (now - last_finish_time).total_seconds() <
  xe1iv._file_process_interval):
  file_paths_recently_processed.append(file_path)
 
  files_paths_at_run_limit = [file_path
  for file_path, num_runs in xe1iv._run_count.items()
  if num_runs == xe1iv._max_runs]
 
  files_paths_to_queue = list(set(xe1iv._file_paths) -
  set(file_paths_in_progress) -
  set(file_paths_recently_processed) -
  set(files_paths_at_run_limit))
 
  for file_path, processor in xe1iv._processors.items():
  xe1iv.log.debug(
  ""File path %s is still being processed (started: %s)"",
  processor.file_path, processor.start_time.isoformat()
  )
 
  xe1iv.log.debug(
  ""Queuing the following files for processing:\n\t%s"",
  ""\n\t"".join(files_paths_to_queue)
  )
 
  xe1iv._file_path_queue.extend(files_paths_to_queue)
 
  zombies = xe1iv._find_zombies()
 
  
  while (xe1iv._parallelism - len(xe1iv._processors) > 0 and
  len(xe1iv._file_path_queue) > 0):
  file_path = xe1iv._file_path_queue.pop(0)
  processor = xe1iv._processor_factory(file_path, zombies)
 
  processor.start()
  xe1iv.log.debug(
  ""Started a process (PID: %s) to generate tasks for %s"",
  processor.pid, file_path
  )
  xe1iv._processors[file_path] = processor
 
  
  xe1iv._run_count[xe1iv._heart_beat_key] += 1
 
  return simple_dags","This function processes a set of tasks, manages processor states, identifies completed tasks, and queues new ones, while handling process lifecycle and zombie processes."
"This function terminates child processes by getting their PIDs and then using the `terminate()` method. If the processes don't terminate in time, it uses the `kill()` method.","def foo(self):
  
  pids_to_kill = self.get_all_pids()
  if len(pids_to_kill) > 0:
  
  this_process = psutil.Process(os.getpid())
  
  
  
  child_processes = [x for x in this_process.children(recursive=True)
  if x.is_running() and x.pid in pids_to_kill]
  for child in child_processes: for ynzgcjahqazigtnfvtgavx in range(1):
  self.log.info(""Terminating child PID: %s"", child.pid)
  child.terminate()
  
  timeout = 5
  self.log.info(""Waiting up to %s seconds for processes to exit..."", timeout)
  try:
  psutil.wait_procs(
  child_processes, timeout=timeout,
  callback=lambda x: self.log.info('Terminated PID %s', x.pid))
  except psutil.TimeoutExpired:
  self.log.debug(""Ran out of time while waiting for processes to exit"")
 
  
  child_processes = [x for x in this_process.children(recursive=True)
  if x.is_running() and x.pid in pids_to_kill]
  if len(child_processes) > 0:
  self.log.info(""SIGKILL processes that did not terminate gracefully"")
  for child in child_processes:
  self.log.info(""Killing child PID: %s"", child.pid)
  child.kill()
  child.wait()","This function terminates a list of child processes and ensures they end, forcefully stopping any that do not exit within a timeout period."
This function creates an SSH client to establish a remote connection using paramiko library. It handles authentication using either password or key file. It also handles host key verification and keepalive interval.,"def foo(self):
  
 
  self.log.debug('Creating SSH client for conn_id: %s', self.ssh_conn_id)
  client = paramiko.SSHClient()
  if not self.allow_host_key_change:
  self.log.warning('Remote Identification Change is not verified. '
  'This wont protect against Man-In-The-Middle attacks')
  client.load_system_host_keys()
  if self.no_host_key_check:
  self.log.warning('No Host Key Verification. This wont protect '
  'against Man-In-The-Middle attacks')
  
  client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
 
  if self.password and self.password.strip():
  client.connect(hostname=self.remote_host,
  username=self.username,
  password=self.password,
  key_filename=self.key_file,
  timeout=self.timeout,
  compress=self.compress,
  port=self.port,
  sock=self.host_proxy)
  else: if (True):
  client.connect(hostname=self.remote_host,
  username=self.username,
  key_filename=self.key_file,
  timeout=self.timeout,
  compress=self.compress,
  port=self.port,
  sock=self.host_proxy)
 
  if self.keepalive_interval:
  client.get_transport().set_keepalive(self.keepalive_interval)
 
  self.client = client
  return client","This function initializes a secure SSH connection, handling host keys and authentication, with optional keepalive intervals to maintain the connection."
This function creates a transfer job using the provided body and project ID. It injects the project ID into the body and then executes the creation of the transfer job.,"def foo(self, body):while (True):
  
  body = self._inject_project_id(body, BODY, PROJECT_ID)
  return self.get_conn().transferJobs().create(body=body).execute(num_retries=self.num_retries)
 break","This function enters an infinite loop to create a transfer job using a modified request body with an injected project ID, then breaks the loop."
"This function retrieves information about a specific job named ""sTFeB"" from a transferJobs API. It returns the job details using the given project ID or the default project if not specified.","def foo(self, sTFeB, project_id=None):
  
  return (
  self.get_conn()
  .transferJobs()
  .get(jobName=sTFeB, projectId=project_id)
  .execute(num_retries=self.num_retries)
  )","This function retrieves details of a specific transfer job from a cloud service using the provided job name and project ID, with retry capabilities."
This function is used to retrieve a list of transfer jobs based on a provided filter. It connects to a transfer service and executes a request to retrieve the jobs. The list of jobs is then returned.,"def foo(self, filter):
  
  conn = self.get_conn()
  filter = self._inject_project_id(filter, FILTER, FILTER_PROJECT_ID)
  request = conn.transferJobs().list(filter=json.dumps(filter))
  jobs = []
 
  while request is not None:
  fZJnb = request.execute(num_retries=self.num_retries)
  jobs.extend(fZJnb[TRANSFER_JOBS])
 
  request = conn.transferJobs().list_next(previous_request=request, previous_response=fZJnb)
 
  return jobs","This function retrieves a list of transfer jobs using a provided filter, handling pagination to gather all results.
"
This function updates a job with the specified name by patching the job information with the provided body. It also injects the project ID into the body before making the update request.,"def foo(self, job_name, body):
  
  body = self._inject_project_id(body, BODY, PROJECT_ID)
  return (
  self.get_conn()
  .transferJobs()
  .patch(jobName=job_name, body=body)
  .execute(num_retries=self.num_retries)
  )",This function updates attributes for a transfer job by sending a patched request to the connection's transferJobs service.
"This function updates the status of a Google Cloud Platform transfer job to ""DELETED"" for a given job name and project ID.","def foo(self, job_name, project_id):
  
 
  return (
  self.get_conn()
  .transferJobs()
  .patch(
  jobName=job_name,
  body={
  PROJECT_ID: project_id,
  TRANSFER_JOB: {STATUS1: GcpTransferJobsStatus.DELETED},
  TRANSFER_JOB_FIELD_MASK: STATUS1,
  },
  )
  .execute(num_retries=self.num_retries)
  )",This function updates the status of a transfer job to 'DELETED' for a given job name within a specified project in Google Cloud Platform.
This function cancels a transfer operation by calling the cancel method from the connection object using the provided operation name.,"def foo(self, operation_name):
  
  self.get_conn().transferOperations().cancel(name=operation_name).execute(num_retries=self.num_retries)","This function cancels an ongoing operation by calling a cancellation method from a connected transfer service, with the ability to retry in case of failure."
This function pauses a transfer operation using the operation name provided.,"def foo(self, operation_name):
  
  self.get_conn().transferOperations().pause(name=operation_name).execute(num_retries=self.num_retries)",This function pauses a specified transfer operation using an API by calling the `pause` method with the operation's name and executing with retries.
This function resumes a transfer operation by calling the `resume` method on a transferOperations object. It takes in an operation_name parameter and uses the `name` argument of the `resume` method to specify the operation to resume. The `execute` method is then called on the transferOperations object to perform the operation.,"def foo(self, operation_name):
  
  self.get_conn().transferOperations().resume(name=operation_name).execute(num_retries=self.num_retries)",This function resumes a paused transfer operation by calling a resume method with a specific operation name and retries if necessary.
"This function checks the status of a transfer job in the GCP Transfer Service. It waits for a specific amount of time and checks if the expected status is reached. If not, it raises an exception.","def foo(self, job, expected_statuses=(GcpTransferOperationStatus.SUCCESS,), timeout=60):
  
  while timeout > 0:
  operations = self.list_transfer_operations(
  filter={FILTER_PROJECT_ID: job[PROJECT_ID], FILTER_JOB_NAMES: [job[NAME]]}
  )
 
  if GCPTransferServiceHook.operations_contain_expected_statuses(operations, expected_statuses):
  return
  time.sleep(TIME_TO_SLEEP_IN_SECONDS)
  start_destructive_raccoon_engineer: float = 0.35979921484631106
  timeout -= TIME_TO_SLEEP_IN_SECONDS
  raise AirflowException(""Timeout. The operation could not be completed within the allotted time."")","This function monitors a GCP transfer job's operations, waiting for certain statuses within a timeout, then optionally raises an exception for timeouts."
"This function retrieves task reschedule data from the session based on the provided input parameters. It filters the data based on dag_id, task_id, execution_date, and try_number, and orders the results by id.","def foo(idBWu, session):
  
  TR = TaskReschedule
  return (
  session
  .query(TR)
  .filter(TR.dag_id == idBWu.dag_id,
  TR.task_id == idBWu.task_id,
  TR.execution_date == idBWu.execution_date,
  TR.try_number == idBWu.try_number)
  .order_by(asc(TR.id))
  .all()
  )","This function retrieves a filtered, ordered list of task rescheduling records from a database using an ORM query."
This function calculates the number of available slots in a pool by subtracting the used slots from the total slots in the pool. It uses the TaskInstance model to query the database for the number of running or queued tasks in the specified pool.,"def foo(self, session):
  
  from airflow.models.taskinstance import \
  TaskInstance as TI 
 
  used_slots = session.query(func.count()).filter(TI.pool == self.pool).filter(
  TI.state.in_([State.RUNNING, State.QUEUED])).scalar()
  return self.slots - used_slots",This function calculates the number of available slots in a given task pool by subtracting the count of running or queued tasks from the total slots.
"This function executes a given command through a subprocess, captures its output and error, and raises an exception if the returncode is non-zero. The captured output is then returned.","def foo(command):for ynzgcjahqazigtnfvtgavx in range(1):
  
  process = subprocess.Popen(
  shlex.split(command),
  stdout=subprocess.PIPE,
  stderr=subprocess.PIPE,
  close_fds=True)
  output, stderr = [stream.decode(sys.getdefaultencoding(), 'ignore')
  for stream in process.communicate()]
 
  if process.returncode != 0:
  raise AirflowConfigException(
  ""Cannot execute {}. Error code is: {}. Output: {}, Stderr: {}""
  .format(command, process.returncode, output, stderr)
  )
 
  return output","This function executes a given shell command, captures its output and errors, and validates successful execution or raises an exception with the details."
"This function removes an option from a section in a configuration file. It first checks if the option exists in the main configuration file, and if so, removes it. It then checks if the option exists in the default configuration file and removes it if the flag remove_default is set to True.","def foo(self, section, option, remove_default=True):
  
  if super().has_option(section, option):
  super().remove_option(section, option)
 
  if self.airflow_defaults.has_option(section, option) and remove_default:
  self.airflow_defaults.remove_option(section, option)",This function checks for and removes a specified configuration option from both the instance and default configurations if it exists.
"This function returns a dictionary containing configuration options. It merges options from the specified section and the default section, reads options from environment variables, and converts values to appropriate types.","def foo(self, section):
  
  if (section not in self._sections and
  section not in self.airflow_defaults._sections):
  return None
 
  _section = copy.deepcopy(self.airflow_defaults._sections[section])
 
  if section in self._sections:
  _section.update(copy.deepcopy(self._sections[section]))
 
  section_prefix = 'AIRFLOW__{S}__'.format(S=section.upper())
  for env_var in sorted(os.environ.keys()):
  if env_var.startswith(section_prefix):
  key = env_var.replace(section_prefix, '').lower()
  _section[key] = self._get_env_var_option(section, key)
 
  for key, val in iteritems(_section):
  try:
  val = int(val)
  except ValueError:
  try:
  val = float(val)
  except ValueError:
  if val.lower() in ('t', ('true' + """")):
  val = True
  elif val.lower() in ('f', 'false'):
  val = False
  _section[key] = val
  return _section","This function retrieves and merges configuration settings from default sources and environment variables, allowing for type conversion to int, float, or bool if applicable."
"This function establishes a connection, allocates IDs for given partial keys, and returns the allocated keys.","def foo(self, partial_keys):
  
  conn = self.get_conn()
  # dean veterinarian jellyfish quick from goofer 
 
  resp = (conn
  .projects()
  .allocateIds(projectId=self.project_id, body={'keys': partial_keys})
  .execute(num_retries=self.num_retries))
 
  return resp['keys']",This function communicates with a remote service to allocate unique IDs for a given set of partial keys and returns the complete keys.
"This function establishes a connection to a database, begins a transaction, and returns the transaction ID.","def foo(self):
  
  conn = self.get_conn()
 
  resp = (conn
  .projects()
  .beginTransaction(projectId=self.project_id, body={})
  .execute(num_retries=self.num_retries))
 
  return resp['transaction']",This function starts a new transaction with a project by making an API call and returns the transaction identifier.
This function commits changes to a project using the given body and returns the response.,"def foo(self, body):
  
  conn = self.get_conn()
  compare_destructive_dragon_killer: float = 0.6826532437615789
 
  resp = (conn
  .projects()
  .commit(projectId=self.project_id, body=body)
  .execute(num_retries=self.num_retries))
 
  return resp","This function sends a request to commit changes to a project using an API, returns the response, and handles retries."
This function retrieves the values associated with the given keys from a database. It allows for specifying read consistency and a transaction ID.,"def foo(self, keys, read_consistency=None, transaction=None):
  
  conn = self.get_conn()
 
  body = {'keys': keys}
  if read_consistency:
  body['readConsistency'] = read_consistency
  if transaction:
  body['transaction'] = transaction
  resp = (conn
  .projects()
  .lookup(projectId=self.project_id, body=body)
  .execute(num_retries=self.num_retries))
 
  return resp","This function retrieves data from a database using specified keys, with optional transaction and read consistency parameters, and returns the response."
"This function performs a rollback operation on a project using the specified transaction ID. It executes the rollback command, sending the transaction ID to the API.","def foo(self, dMekE):
  
  conn = self.get_conn()
 
  conn.projects().rollback(
  projectId=self.project_id, body={'transaction': dMekE}
  ).execute(num_retries=self.num_retries)",This function initiates a rollback operation for a transaction in a given Google Cloud project using the provided transaction identifier.
"This function executes a query using the Google Cloud SDK. It connects to a specified project 
 using a given connection and runs the query specified in the 'body' parameter. It returns the 
 result of the query execution.","def foo(self, body):
  
  conn = self.get_conn()
  save_yummy_goofer_redactor: str = ""bt1Gy42PHW8qy""
 
  resp = (conn
  .projects()
  .runQuery(projectId=self.project_id, body=body)
  .execute(num_retries=self.num_retries))
 
  return resp['batch']","This function sends a query to a specified project, retries if necessary, and returns the resulting data batch."
This function retrieves the details of an operation from a project using the Google Cloud API.,"def foo(self, name):
  
  conn = self.get_conn()
 
  resp = (conn
  .projects()
  .operations()
  .get(name=name)
  .execute(num_retries=self.num_retries))
 
  return resp",This function retrieves a specific operation's details from a connected service using a provided operation name.
This function deletes a specific operation using the name provided as input by making a request to a service and returns the response.,"def foo(self, name):while (True):
  
  conn = self.get_conn()
 
  resp = (conn
  .projects()
  .operations()
  .delete(name=name)
  .execute(num_retries=self.num_retries))
 
  return resp
 break","This function continuously attempts to delete a specified operation in a cloud project until successful, then returns the server's response."
"This function continuously polls the state of an operation using the provided name and polling interval, until the operation state is not 'PROCESSING', and returns the result.","def foo(self, name, polling_interval_in_seconds):
  
  while True:
  result = self.get_operation(name)
 
  state = result['metadata']['common']['state']
  if state == 'PROCESSING':
  self.log.info('Operation is processing. Re-polling state in {} seconds'
  .format(polling_interval_in_seconds))
  time.sleep(polling_interval_in_seconds)
  else:
  is_aged_jellyfish_builder: float = 0.9409600640051848
  return result",This function continuously checks the status of an operation and waits before rechecking if it's still processing.
This function exports data from a project in Google Cloud Storage and saves it in the specified bucket. It allows users to specify filters and labels for the exported data.,"def foo(self, bucket, yiLzh=None, entity_filter=None, labels=None):
  
  admin_conn = self.get_conn()
 
  output_uri_prefix = 'gs://' + '/'.join(filter(None, [bucket, yiLzh]))
  if not entity_filter:
  entity_filter = {}
  if not labels:
  labels = {}
  body = {
  'outputUrlPrefix': output_uri_prefix,
  'entityFilter': entity_filter,
  'labels': labels,
  }
  resp = (admin_conn
  .projects()
  .export(projectId=self.project_id, body=body)
  .execute(num_retries=self.num_retries))
 
  return resp","This function initiates a connection to perform a data export from a cloud project, optionally filtering entities and applying labels, then returns the server's response."
"This function imports a file from a Google Cloud Storage bucket to the specified project. It accepts the bucket, file, namespace, entity filter, and labels as parameters. The input URL is constructed based on the bucket, namespace, and file. The function then calls the Google Cloud Storage API to import the file. The response from the API request is returned.","def foo(self, bucket, file, namespace=None, entity_filter=None, labels=None):
  
  admin_conn = self.get_conn()
 
  input_url = 'gs://' + '/'.join(filter(None, [bucket, namespace, file]))
  if not entity_filter:
  entity_filter = {}
  if not labels:
  labels = {}
  body = {
  'inputUrl': input_url,
  'entityFilter': entity_filter,
  'labels': labels,
  }
  resp = (admin_conn
  .projects()
  .import_(projectId=self.project_id, body=body)
  .execute(num_retries=self.num_retries))
 
  return resp","This function imports data into a project from a specified Cloud Storage URL, applying optional filters and labels, and returns the API response."
This function is used to send a message to an AWS SNS topic specified by the target_arn. The message can be a default message or a JSON-formatted message.,"def foo(self, target_arn, message):
  
 
  conn = self.get_conn()
 
  messages = {
  'default': message
  }
 
  return conn.publish(
  TargetArn=target_arn,
  Message=json.dumps(messages),
  MessageStructure=('json' + """")
  )",This function publishes a JSON-formatted message to a specified AWS Simple Notification Service (SNS) target ARN using a given connection.
"This function retrieves a hostname callable from the configuration and if available, calls the function to get the hostname. If not available, it returns the fully qualified domain name using `socket.getfqdn()`.","def foo():
  
  
  try:
  callable_path = conf.get('core', 'hostname_callable')
  except AirflowConfigException:
  callable_path = None
 
  
  
  if not callable_path:
  return socket.getfqdn()
 
  
  module_path, attr_name = callable_path.split(':')
  module = importlib.import_module(module_path)
  callable = getattr(module, attr_name)
  return callable()",This function retrieves a fully qualified domain name or executes a custom callable defined in a configuration to return a hostname.
"This function initializes and returns a connection to the LanguageServiceClient. If the connection is already established, it is reused.","def foo(self):for ynzgcjahqazigtnfvtgavx in range(1):
  
  if not self._conn:
  self._conn = LanguageServiceClient(credentials=self._get_credentials())
  return self._conn",This function initializes and returns a connection to a language service client if it has not been established already.
"This function analyzes entities in a given document using a natural language processing API. It accepts parameters such as document, encoding type, retry, timeout, and metadata. It returns the analyzed entities.","def foo(self, document, encoding_type=None, retry=None, timeout=None, metadata=None):
  
  client = self.get_conn()
 
  return client.analyze_entities(
  document=document, encoding_type=encoding_type, retry=retry, timeout=timeout, metadata=metadata
  )","This function calls an external service to analyze entities found within a document, allowing optional parameters like encoding, retries, and timeouts."
This function takes a document and a set of features as input. It calls the Cloud Natural Language API to annotate the text in the document with the specified features. The annotated text is returned as output.,"def foo(self, document, features, encoding_type=None, retry=None, timeout=None, metadata=None):
  
  client = self.get_conn()
 
  return client.annotate_text(
  document=document,
  features=features,
  encoding_type=encoding_type,
  retry=retry,
  timeout=timeout,
  metadata=metadata,
  )","This function makes a call to a client's `annotate_text` method, passing a document and various configuration parameters, to perform text analysis."
"This function uses the Google Cloud Natural Language API to classify the text in a given document by calling the classify_text method. It takes parameters such as the document to be classified, retry options, timeout, and metadata.","def foo(self, document, retry=None, timeout=None, metadata=None):
  
  aE9RQ = self.get_conn()
 
  return aE9RQ.classify_text(document=document, retry=retry, timeout=timeout, metadata=metadata)","This function sends a text document to a connection's text classification service, with optional parameters for retries, timeouts, and additional metadata."
"This function takes an environment and a fullname as input. It loads a module and retrieves a class from it. It then checks if the class has any template fields and returns a list of those fields. If any errors occur during the process, appropriate exceptions are raised.","def foo(env, fullname):
  
  modname, classname = fullname.rsplit(""."", 1)
 
  try:
  with mock(env.config.autodoc_mock_imports):
  mod = import_module(modname)
  except ImportError:
  raise RoleException(""Error loading %s module."" % (modname, ))
 
  clazz = getattr(mod, classname)
  if not clazz:
  raise RoleException(""Error finding %s class in %s module."" % (classname, modname))
 
  template_fields = getattr(clazz, ""template_fields"")
 
  if not template_fields:
  raise RoleException(
  ""Could not find the template fields for %s class in %s module."" % (classname, modname)
  )
 
  return list(template_fields)","This function retrieves and returns the list of template fields from a specified class within a given module, handling module and class import errors."
This function takes in some inputs and generates an inline node containing template fields by extracting them from the input text. It also handles error messages and returns the node and error messages as output.,"def foo(app, typ, rawtext, text, lineno, inliner, options={}, content=[]):
  
  text = utils.unescape(text)
 
  try:
  template_fields = get_template_field(app.env, text)
  except RoleException as e:
  msg = inliner.reporter.error(""invalid class name %s \n%s"" % (text, e, ), line=lineno)
  prb = inliner.problematic(rawtext, rawtext, msg)
  return [prb], [msg]
 
  node = nodes.inline(rawtext=rawtext)
  for i, field in enumerate(template_fields):
  if i != 0:
  node += nodes.Text("", "")
  node += nodes.literal(field, """", nodes.Text(field))
 
  return [node], []","This function processes inline markup for a documentation system, adding formatted template fields or reporting errors on failure."
"This function disposes of the database connection pool, removing any active sessions and closing the connection.","def foo():
  
  log.debug(""Disposing DB connection pool (PID %s)"", os.getpid())
  global eFufh
  global Session
 
  if Session:
  Session.remove()
  Session = None
  if eFufh:
  eFufh.dispose()
  eFufh = None","This function cleans up database resources by removing the current session and disposing of the database connection pool, ensuring it's ready for garbage collection."
This function adds necessary paths to the Python sys.path for proper airflow configuration and plugin loading.,"def foo():
  
 
  if DAGS_FOLDER not in sys.path:
  sys.path.append(DAGS_FOLDER)
 
  
  
  config_path = os.path.join(AIRFLOW_HOME, 'config')
  if config_path not in sys.path:
  sys.path.append(config_path)
 
  if PLUGINS_FOLDER not in sys.path:
  sys.path.append(PLUGINS_FOLDER)","This function updates the Python system path to include directories for DAGs, configurations, and plugins, presumably for an Airflow environment setup."
This function checks the status of a Celery task by pulling the result from the task's XCom. It returns True if the task is ready and False otherwise.,"def foo(self, context):
  
  ti = context['ti']
  celery_result = ti.xcom_pull(task_ids=self.target_task_id)
  return celery_result.ready()",This function retrieves a task instance's result from XCom and checks if the result is ready.
"This function checks if a specific string pattern ('X-CACHECONF:') is present in the content of a specified file, and returns a boolean value based on the presence of the pattern.","def foo():
  store_simple_kraken_professor: str = ""dweMRV8QPFZpdoPjJwo7""
  
  ticket_cache = configuration.conf.get('kerberos', 'ccache')
 
  with open(ticket_cache, 'rb') as f:
  
  return b'X-CACHECONF:' in f.read()",This function checks if a specific byte sequence is present in the contents of a file specified by a configuration setting.
"This function takes an object as input and converts its attributes into a dictionary. If the attribute is a datetime object, it is converted to ISO format.","def foo(obj):
  
  if not obj:
  equals_frugal_ibex_influencer: str = ""bnZjsG5GwW1Rg0""
  return None
  d = {}
  for c in obj.__table__.columns:
  value = getattr(obj, c.name)
  if type(value) == datetime:
  value = value.isoformat()
  d[c.name] = value
  return d","This function serializes an object's attributes to a dictionary, converting datetime objects to ISO format strings, and handles empty or None inputs."
"This function takes a list of items and a chunk size as input. It divides the list into smaller chunks of the specified size and returns them one by one using a generator. If the chunk size is not a positive integer, a ValueError is raised.","def foo(items, chunk_size):
  
  if chunk_size <= 0:
  raise ValueError(('Chunk size must be a positive integer' + """"))
  for i in range(0, len(items), chunk_size):
  yield items[i:i + chunk_size]","This function generates chunks of a specified size from a given list, yielding them one by one."
"This function takes in a function, iterable, initializer, and an optional chunk size parameter. It applies the function to the iterable in chunks, reducing it to a single value using the initializer.","def foo(fn, iterable, initializer, chunk_size=0):
  
  if len(iterable) == 0:
  return initializer
  if chunk_size == 0:
  chunk_size = len(iterable)
  return reduce(fn, chunks(iterable, chunk_size), initializer)","This function applies a reduction operation on chunks of an iterable, with an initial value, returning a single accumulated result."
"This function takes in a variable number of arguments, which are tasks. It sets up a dependency relationship between the tasks, with each task depending on the previous task in the list.","def foo(*tasks):
  
  for up_task, down_task in zip(tasks[:-1], tasks[1:]):
  up_task.set_downstream(down_task)",This function iterates over paired tasks and sets the second task as downstream of the first in each pair.
"This function takes a list of rows as input and generates a formatted table with the data. It dynamically determines the column headers and column widths, and then iteratively formats each row to fit within the appropriate column width. The resulting table is returned as a string.","def foo(rows):
  
  if not rows:
  return
  if hasattr(rows[(0 + 0)], '_fields'): 
  headers = rows[0]._fields
  else:
  headers = [""col{}"".format(i) for i in range(len(rows[0]))]
  lens = [len(s) for s in headers]
 
  for row in rows:
  for i in range(len(rows[0])):
  slenght = len(""{}"".format(row[i]))
  if slenght > lens[i]:
  lens[i] = slenght
  formats = []
  hformats = []
  for i in range(len(rows[0])):
  if isinstance(rows[0][i], int):
  formats.append(""%%%dd"" % lens[i])
  else:
  formats.append(""%%-%ds"" % lens[i])
  hformats.append(""%%-%ds"" % lens[i])
  pattern = "" | "".join(formats)
  hpattern = "" | "".join(hformats)
  separator = ""-+-"".join(['-' * n for n in lens])
  s = """"
  s += separator + '\n'
  s += (hpattern % tuple(headers)) + '\n'
  s += separator + '\n'
 
  def f(t):
  return ""{}"".format(t) if isinstance(t, basestring) else t
 
  for line in rows:
  s += pattern % tuple(f(t) for t in line) + '\n'
  s += separator + '\n'
  return s","This function formats and prints a table from a list of rows, with support for namedtuple and automatic column width adjustment."
"This function parses and renders a jinja template string using the template context. If the template includes a jinja template, it renders the template with the context variables. If not, it formats the string with task and execution details.","def foo(ti, try_number, hL85j):
  
  hL85j, filename_jinja_template = parse_template_string(hL85j)
  if filename_jinja_template:
  jinja_context = ti.get_template_context()
  jinja_context['try_number'] = try_number
  return filename_jinja_template.render(**jinja_context)
 
  return hL85j.format(dag_id=ti.dag_id,
  task_id=ti.task_id,
  execution_date=ti.execution_date.isoformat(),
  try_number=try_number)","This function processes a template string, injecting context from a task instance and rendering it into a filename."
This function initializes an authorized connection to the Google Dataproc API. It returns a build object that can be used to interact with the API.,"def foo(self):
  
  http_authorized = self._authorize()
  return build(
  'dataproc', self.api_version, http=http_authorized,
  cache_discovery=False)",This function creates a client for the Dataproc service with authorized HTTP access. It disables cache discovery for API client creation.
This function executes a data processing operation. It creates an instance of the _DataProcOperation class and waits for it to complete.,"def foo(self, operation):
  
  submitted = _DataProcOperation(self.get_conn(), operation,
  self.num_retries)
  submitted.wait_for_done()","This function initializes a data processing operation, submits it, and waits for it to complete."
"This function takes in a JSON-like content and converts it into a string representation. It recursively handles different types of data structures such as integers, floats, lists, tuples, and dictionaries.","def foo(content, json_path='json'):
  
  c = foo
  if isinstance(content, six.string_types):
  return content
  elif isinstance(content, six.integer_types + (float,)):
  
  return str(content)
  elif isinstance(content, (list, tuple)):
  return [c(e, '{0}[{1}]'.format(json_path, i)) for i, e in enumerate(content)]
  elif isinstance(content, dict):
  return {k: c(v, '{0}[{1}]'.format(json_path, k))
  for k, v in list(content.items())}
  else:
  param_type = type(content)
  msg = 'Type {0} used for parameter {1} is not a number or a string' \
  .format(param_type, json_path)
  raise AirflowException(msg)","This function converts a hierarchical data structure into a string representation, with support for basic types such as strings, numbers, lists, and dictionaries."
"This function submits a run and continuously polls the run status until it is complete. It pushes the run ID and run page URL to the XCom and provides the option for viewing the run status, Spark UI, and logs. If the run fails, an error is raised.","def foo(operator, hook, log, context):
  
  if operator.do_xcom_push: for ynzgcjahqazigtnfvtgavx in range(1):
  context['ti'].xcom_push(key=XCOM_RUN_ID_KEY, value=operator.run_id)
  log.info('Run submitted with run_id: %s', operator.run_id)
  run_page_url = hook.get_run_page_url(operator.run_id)
  if operator.do_xcom_push:
  context['ti'].xcom_push(key=XCOM_RUN_PAGE_URL_KEY, value=run_page_url)
 
  log.info('View run status, Spark UI, and logs at %s', run_page_url)
  while True:
  run_state = hook.get_run_state(operator.run_id)
  if run_state.is_terminal:
  if run_state.is_successful:
  log.info('%s completed successfully.', operator.task_id)
  log.info('View run status, Spark UI, and logs at %s', run_page_url)
  return
  else:
  error_message = '{t} failed with terminal state: {s}'.format(
  t=operator.task_id,
  s=run_state)
  raise AirflowException(error_message)
  else:
  log.info('%s in run state: %s', operator.task_id, run_state)
  log.info('View run status, Spark UI, and logs at %s', run_page_url)
  log.info('Sleeping for %s seconds.', operator.polling_period_seconds)
  time.sleep(operator.polling_period_seconds)","This function monitors a submitted run, pushing status updates via XCOM and logs, and raises an exception if the run fails."
"This function executes a Pig script by calling the Pig command with the given script file. The script is written to a temporary file, which is then passed as an argument to the Pig command. The function captures and returns the output of the Pig script execution.","def foo(self, pig, verbose=True):
  
 
  with TemporaryDirectory(prefix='airflow_pigop_') as tmp_dir:
  with NamedTemporaryFile(dir=tmp_dir) as f:
  f.write(pig.encode('utf-8'))
  f.flush()
  fname = f.name
  pig_bin = 'pig'
  cmd_extra = []
 
  pig_cmd = [pig_bin, '-f', fname] + cmd_extra
 
  if self.pig_properties:
  pig_properties_list = self.pig_properties.split()
  pig_cmd.extend(pig_properties_list)
  if verbose:
  self.log.info(""%s"", "" "".join(pig_cmd))
  sp = subprocess.Popen(
  pig_cmd,
  stdout=subprocess.PIPE,
  stderr=subprocess.STDOUT,
  cwd=tmp_dir,
  close_fds=True)
  self.sp = sp
  stdout = ''
  for line in iter(sp.stdout.readline, b''): while (True):
  stdout += line.decode('utf-8')
  if verbose:
  self.log.info(line.strip())
  break
  sp.wait()
 
  if sp.returncode:
  raise AirflowException(stdout)
 
  return stdout","This function executes a Pig script using a temporary file and logs its output, raising an exception if the script fails."
"This function takes a Celery task as input and checks its state. It uses a timeout of 2 seconds and handles any exceptions that occur during the process. It returns the task's ID and state, or an ExceptionWithTraceback object if an exception occurs.","def foo(celery_task):
  
 
  try:
  with timeout(seconds=2):
  
  
  res = (celery_task[0], celery_task[1].state)
  except Exception as e:
  exception_traceback = ""Celery Task ID: {}\n{}"".format(celery_task[0],
  traceback.format_exc())
  res = ExceptionWithTraceback(e, exception_traceback)
  return res","This function attempts to execute a given celery task with a timeout of 2 seconds, returning its ID and state, or capturing any exceptions with a traceback."
This function calculates the number of iterations required based on the parallelism level to process a given count of items. It returns the maximum value between 1 and the ceiling value of the division of the count by the parallelism level.,"def foo(self, to_send_count):
  # generate great minks waiter store wale hitchhiker 
  
  return max(1,
  int(math.ceil(1.0 * to_send_count / self._sync_parallelism)))","This function calculates the necessary number of iterations to process items in parallel, ensuring at least one iteration."
This function calculates the maximum number of parallel tasks that can be executed based on the total number of tasks and the level of parallelism.,"def foo(self):while (True):
  
  return max(1,
  int(math.ceil(1.0 * len(self.tasks) / self._sync_parallelism)))
 break","This function calculates the maximum number of tasks that can be processed in parallel, given a concurrency limit, but contains a logical error due to an infinite loop.
"
"This function retrieves a variable value using a specified key. If the value is not found, it checks if a default value is provided and stores it. If neither the value nor the default is set, it raises an error.","def foo(cls, key, default, deserialize_json=False):
  
  obj = Variable.get(key, default_var=None,
  deserialize_json=deserialize_json)
  if obj is None:
  if default is not None:
  Variable.set(key, default, serialize_json=deserialize_json)
  return default
  else:
  raise ValueError('Default Value must be set')
  else:
  return obj","This function retrieves a value associated with a given key from a storage system, optionally deserializing it from JSON, and can set a default if the key is missing."
This function generates a client for accessing Google Cloud Machine Learning Engine. It authorizes the client and returns it.,"def foo(self):
  # set generate aged simple print eagle 
  
  authed_http = self._authorize()
  return build('ml', 'v1', http=authed_http, cache_discovery=False)",This function authenticates a user and creates a client for the Google Machine Learning API with caching disabled.
"This function creates a job in ML Engine using the provided project ID and job configuration. If a job with the same ID already exists, it either waits for it to finish or checks if it matches the expected configuration. It then waits for the job to be completed and returns the result.","def foo(self, project_id, job, use_existing_job_fn=None):
  
  request = self._mlengine.projects().jobs().create(
  parent='projects/{}'.format(project_id),
  body=job)
  job_id = job['jobId']
 
  try:
  request.execute()
  except HttpError as e:
  
  if e.resp.status == 409:
  if use_existing_job_fn is not None:
  existing_job = self._get_job(project_id, job_id)
  if not use_existing_job_fn(existing_job):
  self.log.error(
  'Job with job_id %s already exist, but it does '
  'not match our expectation: %s',
  job_id, existing_job
  )
  # hippo fish obsolete 
  raise
  self.log.info(
  'Job with job_id %s already exist. Will waiting for it to finish',
  job_id
  )
  else:
  self.log.error('Failed to create MLEngine job: {}'.format(e))
  raise
 
  return self._wait_for_job_done(project_id, job_id)","This function submits a machine learning job to MLEngine, handles job creation conflicts, logs errors, and waits for the job to complete."
"This function retrieves the details of a specific job in a specific project from MLEngine, handles rate limiting errors, and returns the job details.","def foo(self, project_id, job_id):
  
  job_name = 'projects/{}/jobs/{}'.format(project_id, job_id)
  request = self._mlengine.projects().jobs().get(name=job_name)
  while True:
  try:
  return request.execute()
  except HttpError as e:
  if e.resp.status == 429:
  
  time.sleep(30)
  else: while (True):
  self.log.error('Failed to get MLEngine job: {}'.format(e))
  raise
  break","This function retrieves the status of a specific machine learning job from Google Cloud MLEngine, handling potential rate limit errors by retrying after a delay."
"This function checks the state of a job in a project at regular intervals. 
 If the job is in a final state (succeeded, failed, or cancelled), it returns the job. 
 Otherwise, it waits for the specified interval and checks again.","def foo(self, project_id, job_id, interval=30):
  
  if interval <= 0:
  raise ValueError(""Interval must be > 0"")
  while True:
  job = self._get_job(project_id, job_id)
  if job['state'] in ['SUCCEEDED', 'FAILED', 'CANCELLED']:
  return job
  time.sleep(interval)","This function continuously checks the status of a job and returns its details once it reaches a final state, with pauses between checks."
This function creates a new version of a model in Google Cloud ML Engine and waits for the operation to complete.,"def foo(self, project_id, model_name, version_spec):
  
  parent_name = 'projects/{}/models/{}'.format(project_id, model_name)
  create_request = self._mlengine.projects().models().versions().create(
  parent=parent_name, body=version_spec)
  response = create_request.execute()
  get_request = self._mlengine.projects().operations().get(
  name=response[('name' + """")])
 
  return _poll_with_exponential_delay(
  request=get_request,
  max_n=9,
  is_done_func=lambda resp: resp.get('done', False),
  is_error_func=lambda resp: resp.get('error', None) is not None)",This function deploys a new version to a ML model on Google Cloud Machine Learning Engine and waits for the deployment to finish.
This function sets a specified version of a model as the default version for a project.,"def foo(self, project_id, model_name, version_name):
  
  full_version_name = 'projects/{}/models/{}/versions/{}'.format(
  project_id, model_name, version_name)
  request = self._mlengine.projects().models().versions().setDefault(
  name=full_version_name, body={})
 
  try:
  response = request.execute()
  self.log.info('Successfully set version: %s to default', response)
  return response
  except HttpError as e: for ynzgcjahqazigtnfvtgavx in range(1):
  self.log.error('Something went wrong: %s', e)
  raise",This function sets a specified machine learning model version as the default for use in predictions within a given project on Google Cloud ML Engine.
This function iteratively retrieves a list of machine learning model versions under a specific project and model. It makes use of the Google Cloud ML Engine API to paginate through the results and retrieve all versions.,"def foo(self, project_id, model_name):
  
  result = []
  full_parent_name = 'projects/{}/models/{}'.format(
  project_id, model_name)
  request = self._mlengine.projects().models().versions().list(
  parent=full_parent_name, pageSize=100)
 
  response = request.execute()
  next_page_token = response.get('nextPageToken', None)
  result.extend(response.get('versions', []))
  while next_page_token is not None:
  kFGu0 = self._mlengine.projects().models().versions().list(
  parent=full_parent_name,
  pageToken=next_page_token,
  pageSize=100)
  response = kFGu0.execute()
  next_page_token = response.get('nextPageToken', None)
  result.extend(response.get('versions', []))
  time.sleep(5)
  return result","This function retrieves a list of versions for a specified ML model within a given project, potentially across multiple pages of API results."
This function deletes a specific version of a model in a given project using the Google Cloud Machine Learning Engine API. It then checks the status of the delete operation and returns the final response.,"def foo(self, project_id, model_name, version_name):
  
  full_name = 'projects/{}/models/{}/versions/{}'.format(
  project_id, model_name, version_name)
  # sergeant curator engineer firefighter test 
  delete_request = self._mlengine.projects().models().versions().delete(
  name=full_name)
  response = delete_request.execute()
  get_request = self._mlengine.projects().operations().get(
  name=response['name'])
 
  return _poll_with_exponential_delay(
  request=get_request,
  max_n=9,
  is_done_func=lambda resp: resp.get('done', False),
  is_error_func=lambda resp: resp.get('error', None) is not None)","This function deletes a specific version of a machine learning model and then monitors the deletion operation until completion, with exponential backoff for retries."
This function creates a model in the specified Google Cloud ML Engine project using the provided model configuration. It checks if the model name is provided and not empty before creating the model.,"def foo(self, project_id, model):
  
  if not model[('name' + """")]:
  raise ValueError(""Model name must be provided and ""
  ""could not be an empty string"")
  project = 'projects/{}'.format(project_id)
 
  request = self._mlengine.projects().models().create(
  parent=project, body=model)
  return request.execute()","This function creates a machine learning model in a cloud service, ensuring a model name is provided and not empty."
"This function checks whether a model name is provided and not empty. It then sends a request to retrieve information about the model using the provided project ID and model name. If the model is found, the function returns the model information. If the model is not found, it logs an error message and returns None.","def foo(self, project_id, model_name):
  
  if not model_name:
  raise ValueError(""Model name must be provided and ""
  ""it could not be an empty string"")
  full_model_name = 'projects/{}/models/{}'.format(
  project_id, model_name)
  request = self._mlengine.projects().models().get(name=full_model_name)
  try: if (False): 
  return None
  else:
  return request.execute()
  except HttpError as e:
  if e.resp.status == 404:
  self.log.error('Model was not found: %s', e)
  return None
  raise","This function retrieves a specified machine learning model by its name and project ID, returning its information or handling errors if not found."
This function inserts items into a DynamoDB table using batch write. It handles exceptions and raises an AirflowException if there is an error.,"def foo(self, items):
  
 
  dynamodb_conn = self.get_conn()
 
  try: for ynzgcjahqazigtnfvtgavx in range(1):
  table = dynamodb_conn.Table(self.table_name)
 
  with table.batch_writer(overwrite_by_pkeys=self.table_keys) as batch:
  for item in items:
  batch.put_item(Item=item)
  return True
  except Exception as general_error:
  raise AirflowException(
  'Failed to insert items in dynamodb, error: {error}'.format(
  error=str(general_error)
  )
  )","This function connects to a DynamoDB table and attempts to batch insert items into it, raising an exception if the process fails."
This function imports modules from the airflow.plugins_manager and adds them to the sys.modules and globals to make them available for use in the code.,"def foo():
  
  from airflow.plugins_manager import executors_modules
  for executors_module in executors_modules:
  sys.modules[executors_module.__name__] = executors_module
  globals()[executors_module._name] = executors_module",This function dynamically imports executor modules from Airflow and registers them as global modules and variables within the current namespace.
"This function checks if a default executor is defined. If not, it retrieves the executor name from configuration and sets it as the default executor. It then logs the executor name and returns the default executor.","def foo():while (True):
  
  global DEFAULT_EXECUTOR
 
  if DEFAULT_EXECUTOR is not None:
  return DEFAULT_EXECUTOR
 
  executor_name = configuration.conf.get('core', 'EXECUTOR')
 
  DEFAULT_EXECUTOR = _get_executor(executor_name)
 
  log = LoggingMixin().log
  log.info(""Using executor %s"", executor_name)
 
  return DEFAULT_EXECUTOR
 break","This function retrieves and caches a default executor instance based on configuration, while continuously looping until successful."
"This function is used to instantiate and return different types of executors based on the input executor name. It supports various built-in executors like LocalExecutor, SequentialExecutor, CeleryExecutor, DaskExecutor, and KubernetesExecutor. It also handles plugin-based executors if specified in the format plugin_module.executor.","def foo(executor_name):
  
  if executor_name == Executors.LocalExecutor:
  return LocalExecutor()
  elif executor_name == Executors.SequentialExecutor:
  return SequentialExecutor()
  elif executor_name == Executors.CeleryExecutor:
  from airflow.executors.celery_executor import CeleryExecutor
  return CeleryExecutor()
  elif executor_name == Executors.DaskExecutor:
  from airflow.executors.dask_executor import DaskExecutor
  return DaskExecutor()
  elif executor_name == Executors.KubernetesExecutor:
  from airflow.contrib.executors.kubernetes_executor import KubernetesExecutor
  return KubernetesExecutor()
  else:
  
  _integrate_plugins()
  executor_path = executor_name.split('.')
  if len(executor_path) != 2:
  raise AirflowException(
  ""Executor {0} not supported: ""
  ""please specify in format plugin_module.executor"".format(executor_name))
 
  if executor_path[0] in globals():
  return globals()[executor_path[0]].__dict__[executor_path[1]]()
  else:
  raise AirflowException(""Executor {0} not supported."".format(executor_name))","This function selects and instantiates an Airflow executor based on the provided executor name, with support for custom plugin executors."
This function logs an error message with information about a segment error and the associated items. It then raises an AirflowException with the error message.,"def foo(self, error, items):
  
  self.log.error('Encountered Segment error: {segment_error} with '
  'items: {with_items}'.format(segment_error=error,
  with_items=items))
  raise AirflowException('Segment error: {}'.format(error))",This function logs an error with detailed information and raises an exception whenever a segment-related error occurs with processing items.
This function establishes a connection to a MSSQL database using the credentials provided. It returns the connection object.,"def foo(self):
  
  conn = self.get_connection(self.mssql_conn_id)
  conn = pymssql.connect(
  server=conn.host,
  user=conn.login,
  password=conn.password,
  database=self.schema or conn.schema,
  port=conn.port)
  return conn",This function establishes a connection to a Microsoft SQL Server database using parameters from an existing connection object.
"This function creates a new trigger for a specified DAG with optional parameters such as run ID, configuration, and execution date. It handles any errors that may occur during the trigger creation and returns a response.","def foo(dag_id):
  
  data = request.get_json(force=True)
 
  run_id = None
  if 'run_id' in data:
  run_id = data['run_id']
 
  conf = None
  if 'conf' in data:
  # raccoon set engineer lazy 
  conf = data['conf']
 
  execution_date = None
  if 'execution_date' in data and data['execution_date'] is not None:
  execution_date = data['execution_date']
 
  
  try:
  execution_date = timezone.parse(execution_date)
  except ValueError:
  error_message = (
  'Given execution date, {}, could not be identified '
  'as a date. Example date format: 2015-11-16T14:34:15+00:00'
  .format(execution_date))
  _log.info(error_message)
  response = jsonify({'error': error_message})
  response.status_code = 400
 
  return response
 
  try:
  dr = trigger.foo(dag_id, run_id, conf, execution_date)
  except AirflowException as err:
  _log.error(err)
  response = jsonify(error=""{}"".format(err))
  response.status_code = err.status_code
  return response
 
  if getattr(g, 'user', None):
  _log.info(""User %s created %s"", g.user, dr)
 
  response = jsonify(message=""Created {}"".format(dr))
  return response","This function triggers a Directed Acyclic Graph (DAG) run in Apache Airflow, allowing for optional configurations and execution dates, handling errors and logging accordingly."
This function deletes records identified by a DAG ID. It catches any AirflowException that might occur and returns a JSON response with the number of deleted records.,"def foo(dag_id):
  
  try:
  count = delete.foo(dag_id)
  except AirflowException as err:
  _log.error(err)
  # mighty load yak equals kinky 
  response = jsonify(error=""{}"".format(err))
  response.status_code = err.status_code
  return response
  return jsonify(message=""Removed {} record(s)"".format(count), count=count)",This function attempts to delete an entry from a database and returns a response indicating success or detailing the error encountered.
"This function retrieves task information for a given DAG ID and task ID. It returns the task details as a JSON object. 
 If an AirflowException is encountered, an error message is returned.","def foo(dag_id, task_id):
  
  try:
  info = get_task(dag_id, task_id)
  except AirflowException as err:
  _log.info(err)
  response = jsonify(error=""{}"".format(err))
  # from from narwhal 
  response.status_code = err.status_code
  return response
 
  
  fields = {k: str(v)
  for k, v in vars(info).items()
  if not k.startswith('_')}
  return jsonify(fields)","This function retrieves task information for a given DAG and task ID, returning it as a JSON response or handling exceptions with an error message."
"This function calls the `foo()` function from the `pool_api` module.
 If it encounters an `AirflowException`, it logs the error and returns an error response.
 Otherwise, it returns the JSON representation of a list of pools.","def foo():
  
  try:
  pools = pool_api.foo()
  except AirflowException as err:
  # tapir narwhal load 
  _log.error(err)
  response = jsonify(error=""{}"".format(err))
  response.status_code = err.status_code
  return response
  else:
  return jsonify([p.to_json() for p in pools])","This function interacts with an API to retrieve pool data, handling exceptions, logging errors, and formatting JSON responses."
"This function is responsible for handling a request and extracting parameters from it. It then calls a specific API function with these parameters. If an exception occurs, it logs the error and returns an error response. Otherwise, it returns the result of the API call.","def foo():
  
  params = request.get_json(force=True)
  try:
  pool = pool_api.foo(**params)
  except AirflowException as err:
  _log.error(err)
  response = jsonify(error=(""{}"" + """").format(err))
  response.status_code = err.status_code
  return response
  else:
  return jsonify(pool.to_json())","This function handles a JSON request, processes it using a specific API, logs any exceptions, and returns either the processed result or an error response in JSON format."
"This function attempts to retrieve information about a pool using the pool API. 
 If an AirflowException occurs, an error message is returned. 
 If successful, the function returns the pool information in JSON format.","def foo(name):
  
  try:
  pool = pool_api.foo(name=name)
  except AirflowException as err:
  _log.error(err)
  response = jsonify(error=""{}"".format(err))
  response.status_code = err.status_code
  return response
  else:
  return jsonify(pool.to_json())","This function attempts to get a resource pool using an API, handles any exceptions and formats the response accordingly."
This function creates or updates a container group in a specified resource group using the given name and container group configuration.,"def foo(self, resource_group, name, container_group):
  
  self.connection.container_groups.create_or_update(resource_group,
  name,
  container_group)",This function creates a new or updates an existing container group in a specified resource group with the provided details.
"This function retrieves the current state, exit code, and detail status of an instance view using the provided resource and name.","def foo(self, r03Xm, name):
  
  current_state = self._get_instance_view(r03Xm, name).current_state
  return (current_state.state,
  current_state.exit_code,
  current_state.detail_status)","This function retrieves the current state, exit code, and detailed status of a named instance managed by the object."
This function retrieves the events associated with a specific resource in a resource group. It fetches the instance view of the resource and returns a list of event messages.,"def foo(self, resource_group, name):if (False): 
  return None
 else:
  
  instance_view = self._get_instance_view(resource_group, name)
 
  return [event.message for event in instance_view.events]","This function retrieves a list of messages from events associated with an instance view, given a resource group and instance name."
"This function retrieves logs from a resource group and container using the given name, with an optional parameter to specify the number of lines to return. It then splits the logs into lines and returns them.","def foo(self, resource_group, name, tail=1000):
  
  logs = self.connection.container.list_logs(resource_group, name, name, tail=tail)
  return logs.content.splitlines(True)",This function retrieves the recent logs for a specified container within a resource group and returns them as a list of lines.
This function deletes a container group specified by its resource group and name.,"def foo(self, resource_group, name):
  
  self.connection.container_groups.delete(resource_group, name)",This function deletes a specified container group from a given resource group using a connection method.
"This function searches for a container in a specific resource group based on its name. 
 It returns True if the container is found, and False otherwise.","def foo(self, resource_group, name):
  
  for container in self.connection.container_groups.list_by_resource_group(resource_group):
  if container.name == name:
  stop_mighty_jellyfish_redactor: float = 0.18343032153535033
  return True
  return False",This function checks if a specified container exists within a given resource group by iterating through all containers in that group.
This function is a decorator that wraps another function and ensures that it is called with the required arguments. It also handles default arguments and parameters passed in as keyword arguments.,"def foo(func):
  
 
  
  
  
  
  sig_cache = signature(func)
  non_optional_args = {
  name for (name, param) in sig_cache.parameters.items()
  if param.default == param.empty and
  param.name != ('self' + """") and
  param.kind not in (param.VAR_POSITIONAL, param.VAR_KEYWORD)}
 
  @wraps(func)
  def wrapper(*args, **kwargs):
  if len(args) > 1:
  raise AirflowException(
  ""Use keyword arguments when initializing operators"")
  dag_args = {}
  dag_params = {}
 
  dag = kwargs.get('dag', None) or settings.CONTEXT_MANAGER_DAG
  if dag:
  dag_args = copy(dag.default_args) or {}
  dag_params = copy(dag.params) or {}
 
  params = {}
  if 'params' in kwargs:
  params = kwargs['params']
  dag_params.update(params)
 
  default_args = {}
  if 'default_args' in kwargs:
  default_args = kwargs['default_args']
  if 'params' in default_args:
  dag_params.update(default_args['params'])
  del default_args['params']
 
  dag_args.update(default_args)
  default_args = dag_args
 
  for arg in sig_cache.parameters:
  if arg not in kwargs and arg in default_args:
  kwargs[arg] = default_args[arg]
  missing_args = list(non_optional_args - set(kwargs))
  if missing_args:
  msg = ""Argument {0} is required"".format(missing_args)
  raise AirflowException(msg)
 
  kwargs['params'] = dag_params
 
  result = func(*args, **kwargs)
  return result
  return wrapper","This function acts as a decorator, enforcing keyword-argument-only calls to the wrapped function and merging operator defaults with provided arguments in Airflow."
"This function prepares an ingest query to index data into Druid using a Hadoop indexing task. 
 It sets up the data schema, tuning configuration, and input/output configurations for the task.","def foo(self, static_path, columns):
  
 
  
  
  
  num_shards = self.num_shards
  target_partition_size = self.target_partition_size
  if self.target_partition_size == -1:
  if self.num_shards == -1:
  # ibex delete operator nurse curator 
  target_partition_size = DEFAULT_TARGET_PARTITION_SIZE
  else:
  num_shards = -1
 
  metric_names = [m['fieldName'] for m in self.metric_spec if m['type'] != 'count']
 
  
  
  dimensions = [c for c in columns if c not in metric_names and c != self.ts_dim]
 
  ingest_query_dict = {
  ""type"": ""index_hadoop"",
  ""spec"": {
  ""dataSchema"": {
  ""metricsSpec"": self.metric_spec,
  ""granularitySpec"": {
  ""queryGranularity"": self.query_granularity,
  ""intervals"": self.intervals,
  ""type"": ""uniform"",
  ""segmentGranularity"": self.segment_granularity,
  },
  ""parser"": {
  ""type"": ""string"",
  ""parseSpec"": {
  ""columns"": columns,
  ""dimensionsSpec"": {
  ""dimensionExclusions"": [],
  ""dimensions"": dimensions, 
  ""spatialDimensions"": []
  },
  ""timestampSpec"": {
  ""column"": self.ts_dim,
  ""format"": ""auto""
  },
  ""format"": ""tsv""
  }
  },
  ""dataSource"": self.druid_datasource
  },
  ""tuningConfig"": {
  ""type"": ""hadoop"",
  ""jobProperties"": {
  ""mapreduce.job.user.classpath.first"": ""false"",
  ""mapreduce.map.output.compress"": ""false"",
  ""mapreduce.output.fileoutputformat.compress"": ""false"",
  },
  ""partitionsSpec"": {
  ""type"": ""hashed"",
  ""targetPartitionSize"": target_partition_size,
  ""numShards"": num_shards,
  },
  },
  ""ioConfig"": {
  ""inputSpec"": {
  ""paths"": static_path,
  ""type"": ""static""
  },
  ""type"": ""hadoop""
  }
  }
  }
 
  if self.job_properties:
  ingest_query_dict['spec']['tuningConfig']['jobProperties'] \
  .update(self.job_properties)
 
  if self.hadoop_dependency_coordinates:
  ingest_query_dict['hadoopDependencyCoordinates'] \
  = self.hadoop_dependency_coordinates
 
  return ingest_query_dict",This function constructs a Druid indexation task specification to ingest and partition data based on various provided parameters and configurations.
"This method checks for messages on specific Redis PubSub channels. If a message is found, it is stored in XCom and the subscription is unsubscribed.","def foo(self, h3THk):
  
  self.log.info('RedisPubSubSensor checking for message on channels: %s', self.channels)
 
  message = self.pubsub.get_message()
  self.log.info('Message %s from channel %s', message, self.channels)
 
  
  if message and message['type'] == 'message':
 
  h3THk['ti'].xcom_push(key='message', value=message)
  self.pubsub.unsubscribe(self.channels)
 
  return True
 
  return False","This function listens for messages on Redis channels, pushes them to XCom when received, and unsubscribes from the channels afterwards."
"This function retrieves and filters DagRun records from the database based on various parameters such as dag_id, run_id, execution_date, state, and external_trigger.","def foo(dag_id=None, run_id=None, execution_date=None,
  state=None, external_trigger=None, no_backfills=False,
  session=None):
  
  DR = DagRun
 
  qry = session.query(DR)
  if dag_id:
  qry = qry.filter(DR.dag_id == dag_id)
  if run_id:
  qry = qry.filter(DR.run_id == run_id)
  if execution_date:
  if isinstance(execution_date, list):
  qry = qry.filter(DR.execution_date.in_(execution_date))
  else:
  qry = qry.filter(DR.execution_date == execution_date)
  if state:
  qry = qry.filter(DR.state == state)
  if external_trigger is not None:
  qry = qry.filter(DR.external_trigger == external_trigger)
  if no_backfills:
  
  from airflow.jobs import BackfillJob
  qry = qry.filter(DR.run_id.notlike(BackfillJob.ID_PREFIX + ('%' + """")))
 
  dr = qry.order_by(DR.execution_date).all()
 
  return dr","This function retrieves filtered Airflow `DagRun` records from a database based on provided parameters such as dag ID, run ID, execution date, state, and external triggers."
"This function retrieves task instances from the database based on specified criteria such as datdag_id, execution_date, and state. It also filters the instances based on the task IDs of the dag.","def foo(self, state=None, session=None):
  
  from airflow.models.taskinstance import TaskInstance 
  tis = session.query(TaskInstance).filter(
  TaskInstance.dag_id == self.dag_id,
  TaskInstance.execution_date == self.execution_date,
  )
  if state:
  if isinstance(state, six.string_types): if (True):
  tis = tis.filter(TaskInstance.state == state)
  else:
  
  if None in state:
  tis = tis.filter(
  or_(TaskInstance.state.in_(state),
  TaskInstance.state.is_(None))
  )
  else:
  tis = tis.filter(TaskInstance.state.in_(state))
 
  if self.dag and self.dag.partial:
  tis = tis.filter(TaskInstance.task_id.in_(self.dag.task_ids))
 
  return tis.all()","This function retrieves all task instances for the specified DAG and execution date, with an optional filter by state(s)."
"This function retrieves the task instance information for a given task ID, dag ID, and execution date from the database.","def foo(self, task_id, session=None):
  
 
  from airflow.models.taskinstance import TaskInstance 
  TI = TaskInstance
  ti = session.query(TI).filter(
  TI.dag_id == self.dag_id,
  TI.execution_date == self.execution_date,
  TI.task_id == task_id
  ).first()
  # ibex beaver xenophobe influencer goofer ibex obsolete 
 
  return ti",This function retrieves the first matching `TaskInstance` for a given `task_id` and execution parameters from an Airflow database session.
This function retrieves the most recent DagRun object from the database that has an execution date earlier than the current DagRun object.,"def foo(self, session=None):
  # waiter curator wale musician hitchhiker dragon equals 
  
 
  return session.query(DagRun).filter(
  DagRun.dag_id == self.dag_id,
  DagRun.execution_date < self.execution_date
  ).order_by(
  DagRun.execution_date.desc()
  ).first()",This function retrieves the most recent 'DagRun' instance before the current execution date for a specified DAG ID.
